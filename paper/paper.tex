\documentclass[global,twocolumn]{svjour}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{comment}
\usepackage{paralist}
\usepackage{graphicx}
\graphicspath{{./figs/}}
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{flushend}
\usepackage{hyperref}
\usepackage[firstpage]{draftwatermark}
\usepackage[lighttt]{lmodern}
\usepackage[normalem]{ulem}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{light-gray}{gray}{0.88}

\lstdefinestyle{myML}
{frame=none,
  basicstyle=\ttfamily,
  language=ML,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=true,
  tabsize=2,
  linewidth=2\linewidth
}

\lstdefinestyle{agree}
{frame=none,
  basicstyle=\ttfamily,
  language=ML,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=none,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=true,
  tabsize=2,
  linewidth=2\linewidth,
  morecomment=[l]{--},
  escapeinside={*}{*},
  morekeywords={eq, bool, guarantee, assume, true, false, pre, not, and, or, property, const, Historically, Since, Once, event, annex, Implementation, process, subcomponents}
}

\hyphenation{op-tical net-works semi-conduc-tor Cake-ML}

% Comment macros
\newcommand{\newjunk}[1]{\textcolor{red}{#1}}
\newcommand{\oldjunk}[1]{\sout{#1}}

\newcommand{\konst}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\imp}{\Rightarrow}
\newcommand{\set}[1]{\ensuremath{\{ {#1} \}}}
\newcommand{\sem}[1]{\ensuremath{[\![ #1 ]\!]}}
\newcommand{\kstar}[1]{\ensuremath{{#1}^{*}}}
\newcommand{\Lang}[1]{\ensuremath{{\mathcal L}({#1})}}
\newcommand{\Eqs}{\ensuremath{\mathit{Eqs}}}
\newcommand{\itelse}[3]{\mbox{$\mathtt{if}\ {#1}\ \mathtt{then}\ {#2}\ \mathtt{else}\ {#3}$}}

\newcommand{\figref}[1]{Fig.~\ref{#1}}
\newcommand{\secref}[1]{Sec.~\ref{#1}}
\newcommand{\lineref}[1]{Line~\ref{#1}}
\newcommand{\linesref}[2]{Lines~\ref{#1}--\ref{#2}}

% Acronym macros
\newcommand{\brfcs}{BriefCASE}
\newcommand{\agr}{AGREE}
\newcommand{\splt}{SPLAT}
\newcommand{\ckml}{CakeML}

\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\etal}{\textit{et al.}}
\newcommand{\etc}{\textit{etc.}}
\newcommand{\adhoc}{\textit{ad hoc}}

\journalname{Software and Systems Modeling}

\begin{document}
\title{
  Synthesizing Verified Components for Cyber Assured Systems Engineering
  \thanks{DISTRIBUTION STATEMENT A.  Approved for public release.}
}

\author{
  Eric Mercer\inst{1}    \and
  Konrad Slind\inst{2}   \and
  Isaac Amundson\inst{2} \and
  Darren Cofer\inst{2}   \and
  Junaid Babar\inst{3}   \and
  David Hardin\inst{3}
}

\institute{
  Brigham Young University        \\
  Provo, Utah                     \and
  Applied Research and Technology \\
  Collins Aerospace               \\
  Minneapolis, Minnesota          \and
  Applied Research and Technology \\
  Collins Aerospace               \\
  Cedar Rapids, Iowa
}

\date{Received: date / Revised version: date}

\maketitle

\begin{abstract}
Avionics need to be engineered to be cyber-resilient meaning that systems are able to detect and recover from attacks or safely shutdown.
%
As there are few development tools for cyber-resiliency, designers rely on guidelines and checklists, sometimes missing vulnerabilities until late in the process where remediation is expensive.
%
Our solution is a model-based approach with cyber-resilience-improving transforms that insert high-assurance components such as filters to block malicious data or monitors to detect and alarm anomalous behavior.
%
Novel is our use of model checking and a verified compiler to specify, verify, and synthesize these components.
%
We define \emph{code contracts} as formal specifications that designers write for high-assurance components, and \emph{test contracts} as tests to validate their behavior.
%
A model checker proves whether or not code contracts satisfy test contracts in an iterative development cycle.
%
The same model checker also proves whether or not a system with the inserted components, assuming they adhere to their code contracts, provide the desired cyber-resiliency for the system.
%
We define an algorithm to synthesize implementations for code contracts in a semantics-preserving way that is backed by a verified compiler.
%
The entire workflow is implemented as part of the open source \emph{\brfcs} toolkit.
%
We report on our experience using \brfcs\ with a case study on a UAV system that is transformed to be cyber-resilient to communication and supply chain cyber attacks.
%
Our case study demonstrates that writing code contracts and then synthesizing correct implementations from them is feasible in real-world systems engineering for cyber-resilience.
\end{abstract}

%%
% INTRODUCTION
%%

\section{Introduction} \label{sec:intro}
In recent years, aerospace stakeholders have realized that avionics systems are subject to possible cyber-attacks just like other cyber-physical systems.
%
\footnote{This work was funded in part by the
Defense Advanced Research Projects Agency (DARPA) CASE program.
%
The views expressed are those of the authors and do not reflect the official
policy or position of DARPA or the U.S. Government.}
%
Thus, in addition to being fault-tolerant, safety-critical avionics systems must also be {\em cyber-resilient}.
%
Cyber-resiliency means that the system is tolerant to cyber-attacks just as safety-criticalsystems are tolerant to random faults: they recover and continue to execute their mission function, or safely shut down, as requirements dictate.

Unfortunately, systems engineers are currently given few development tools to help answer even basic questions about potential vulnerabilities and ways to mitigate vulnerabilities.  They instead rely on process-oriented checklists and guidelines.
%
Cyber vulnerabilities are often discovered during penetration testing late in the development process;
%
or worse yet, they may be discovered only after the product has been fielded, necessitating extremely expensive and time-consuming remediation. This is not a sustainable development model.

We have been developing the {\em BriefCASE} \oldjunk{toolsuite} toolkit to address this need.
%
\brfcs\ is a Model-Based Systems Engineering (MBSE) environment built in the Open Source AADL Tool Environment (OSATE) to add new capabilities for building cyber-resilient systems.
%
\footnote{AADL is the acronym for Architecture Analysis and Design Language~\cite{aadl}.}
%
In this paper we describe how it facilitates specifying, testing, verifying, and synthesizing high assurance components inserted into a system to improve its cyber-resiliency.
%
The main organizing concept is that of an architecture-to-architecture \emph{security-improving transform}, achieved via the insertion of new architectural components aimed at mitigating cyber-vulnerabilities.
%
We describe two such transformations in this paper: (1) the insertion of a filter to prevent malformed data from a malicious actor being propagated to downstream components, and (2) the insertion of a runtime monitor to detect (and alert) unexpected behaviors arising from untrusted components.
%
We refer to these as \emph{high-assurance components} because they must be correct and fulfill their intended purpose for the system to be cyber-resilient.

The contributions of this paper relate to the aspects of \brfcs\ concerning evidence that such high-assurance components meet their intended purpose and are properly implemented.
%
We leverage the existing {\agr} model checker to provide evidence of the former and the existing verified \ckml\ compiler to provide evidence of the latter \cite{agree2013,compositional-analysis-agree,nfm:agree,cakeml}.
%
\footnote{AGREE is the acronym for \emph{Assume Guarantee Reasoning Environment}.}
%
Specifically, designers write \emph{contracts} to formally specify input and output properties of the system and its components, and \agr\ proves via model checking whether or not the system composition preserves contract requirements at component inputs and guarantees contract obligations at system outputs.
%
In this way, \agr\ provides the formal framework we use to describe the behavior of an inserted high-assurance component, such as a filter or monitor, and then prove if adding such a component to the system improves cyber-resiliency.

We then use semantics preserving transformations to rewrite contracts into \ckml\ where the \ckml\ compiler then turns such contracts into binaries for the intended target platforms.
%
The verified compiler, with the semantics preserving transforms, ensures that the high-assurance component adheres to its contract specification.
%
This assurance fulfills the underlying assumption of the \agr\ model checker's proof: a component implementation adheres to its contract.

As such, this paper defines a \emph{code contract} language that is a subset of the \agr\ language but with sequential evaluation semantics as opposed to \agr's existing parallel semantics.
%
The sequential semantics are requisite to code synthesis and are defined such that \agr\ is able to still prove the contract composition of the system works.
%
This paper further defines a notion of \emph{test contract} for unit testing code contracts outside of the system composition to verify input to output behavior as well as general properties of the code contract.
%
Intuitively, the behavior of a high assurance component is defined by the designer in a code contract, the designer then writes test contracts to validate that behavior by asking \agr\ to prove if the code contract ensures the output obligations in the test contract under the test contract's input assumptions.
%
Once the designer is satisfied that the code contract is correct, the system composition, with its various contracts, is verified to conclude that the system meets its cyber-requirements.

Showing that a component is properly implemented is accomplished through formal synthesis from the code contract.  This paper presents the Semantic Properties of Language and Automata Theory (\splt) tool that generates \ckml\ code to implement the code contract.
%
\ckml\ is a functional language that includes additional proofs and tools built around it \cite{cakeml}.
%
The \ckml\ compiler itself is verified to generate binary implementations that are equivalent in semantics to the original input program.
%
That proof ensures that the resulting binary exactly preserves the meaning of the original code contract and assures that the component is faithfully implemented over all possible finite inputs.
%
Preliminary work has shown how to extend our work to handle infinite input since most systems of interest are inherently reactive and intended to run forever~\cite{case-verified-filter,cakeml-space-cost}.

We report on a case study applying these transformations with \brfcs\ to an Unmanned Aerial Vehicle (UAV) system that uses the Air Force Research Laboratory's OpenUxAS services for route planning.
%
OpenUxAS, as an open source product, is considered \emph{untrusted}.
%
The UAV system is thus transformed to be resilient to malicious behavior that may arise in the untrusted component.
%
In particular, filters are added to guard against malformed input and a monitor is created to guard against malicious flight plans generated from OpenUxAS.
%
The case study system is complex and shows the viability of the approach in potential full-scale industrial design.

{\brfcs} is open source and publicly available \cite{fmide}, as are the examples and case study we discuss in this paper \cite{repo,
phase2, camkes, case}.

%%
% CONTRIBUTIONS AND LIMITATIONS
%%

\subsubsection*{Contributions and limitations}

As indicated in the preceding discussion, {\brfcs} is aimed at addressing the lack of tool support for the problem of enforcing and implementing the class of cyber-resilience system requirements.
%
Our approach to the problem is embedded in a substantial collection of tools to be wholistic in addressing cyber-resilience at the system level, so it is important to clarify the
research impact.
%
We see the following as the distinguishing contributions of this paper:
\begin{compactitem}
  \item The language and semantics of \emph{code contracts} as a means to join system-level contract analysis results (arising from model checking) with component implementation correctness results (arising from property-preserving code generation).
  \item \emph{Test contracts} as a stylized mechanism to unit test code contracts inside the \brfcs\ framework with \agr.
  \item A strong formal path connecting (A) top-level system cyber-resilience requirements, (B) specifications for high-assurance components inserted to mitigate against specific cyber-resilience problems, and (C) synthesis to a programming language with a verified compiler.
  \item A case study that demonstrates the use of \brfcs\ to add cyber-resiliency to a non-trivial UAV system.
\end{compactitem}

Our approach currently applies to common cyber-vulnerabilities, such as buffer overflow, lack of input validation, and supply-chain issues;
%
however, other cyber-vulnerabilities such as side-channel attacks and denial of service have not yet been addressed. Moreover, this work does not introduce a new type of high-assurance component in terms of capability.
%
Instead, our contribution is in the automated synthesis of security-improving components from formal cyber-resilience specifications, paired with a verification showing that the synthesized implementation is correct in the context of the whole system all the way down to the binary implementation.

We have not yet tried to apply {\brfcs} to problems outside the realm of cyber-resilience;
%
however, the notions of code and test contracts, along with the system analysis and verified code generation facilities promise to be useful in a wide variety of settings.
%
Writing code and test contracts does require a working knowledge of propositional logic but not to a degree that would exceed what would be expected in a designer.
%
The general synthesis approach in this paper could be used outside of the \brfcs\ environment, but it would only then provide guarantees relative to the complied artifacts and not say anything about the correctness of the system composition.

%%
% ORGANIZATION
%%

\subsubsection*{Organization}
The rest of the paper is organized as follows.
%
Our approach is illustrated by a simple example in \secref{sec:example}.
%
Essential background on {\agr} verification and specification are presented in \secref{sec:agree}.
%
The language and semantics of code contracts are defined in \secref{sec:code-contracts}, and test contracts are described in \secref{sec:testing}.
%
The synthesis pathway is covered in \secref{sec:synthesis}.
%
\secref{sec:case-study} discusses the case study.
%
This is followed by related work in \secref{sec:related-work}.
%
The conclusions and future work are in \secref{sec:conclusion}.

%%
% ILLUSTRATIVE EXAMPLE
%%

\section{Illustrative example}
\label{sec:example}

\begin{figure*}
  \begin{center}
    \begin{tabular}{c}
      \includegraphics[width=0.8\textwidth]{flowchart.png} \\
    \end{tabular}
  \end{center}
\caption{A simplified illustration of the \brfcs\ toolkit with shaded portions being the contributions presented here.}
\label{fig:flowchart}
\end{figure*}

\begin{figure*}
	\begin{center}
	  \includegraphics[width=\textwidth]{./figs/workflow.png}
  	\end{center}
	\caption{The general workflow for \brfcs.}
	\label{fig:workflow}
\end{figure*}

The \brfcs\ OSATE environment provides designers with workflow and tool support for developing products with
inherent cyber-resiliency.
%
\figref{fig:flowchart} is a simplified illustration of the toolkit that omits tooling outside of our contributions discussed here (see \cite{dcrypps2019,gearcase2020,resolute-destion,attestation-copland,awas,hamr,sel4-sosp09, sel4-tocs14, sel4-cacm18} for other aspects of \brfcs).
%
The shaded boxes represent our contribution: test contracts, code contracts, and SPLAT synthesis.
The unshaded boxes are the existing tools that provide the foundation for our contributions.

The intended \brfcs\ workflow is in \figref{fig:workflow}.
%
The workflow starts with a behavioral description of the system and its components on the left.
%
These descriptions are contracts that assume properties on inputs and guarantee properties on outputs when the input assumptions hold.
Once \agr\ verifies the system contract composition, the workflow moves right to the threat analysis, and the contracts of the system and components are modified to reflect that analysis.
%
If \agr\ verifies the system contract composition with the changes from the threat analysis, then the workflow moves to the far right for code generation.
%
Otherwise it moves immediate right to transforms.
Here the designer inserts high-assurance components such as filters and monitors, with their accompanying code contracts, until \agr\ verifies the new system composition to be cyber-resilient to the indicated threats.
%
Once \agr\ verifies the new system composition, the workflow moves to code generation, where \splt\ synthesizes implementations for the inserted high-assurance components from their corresponding code contracts.

We use this section to explain both figures in more detail through an example.
%
The example is a UAV system for remote monitoring, and it is loosely based on
the case study in \secref{sec:case-study}.
%
The source for the example is at \cite{repo}.
%
The intent of the UAV system is to receive a mission from the ground station, plan a path to fly that mission from its current location, and then fly the planned path updating the ground station along the way.
%
The system must by cyber-resilient and actively protect itself from malicious actors to ensure it is sending accurate monitoring information back to the ground station and that it actually flies the intended mission.

%%
% SYSTEM AND COMPONENT CONTRACT IMPLEMENTATION
%%

\subsection{System and Component Contract Implementation}

\begin{figure*}[h]
  \begin{center}
    \begin{tabular}{c}
      \includegraphics[width=\textwidth]{example.png}
    \end{tabular}
  \end{center}
\caption{Initial design for an automated UAV route planning system.}
\label{fig:example}
\end{figure*}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
      \includegraphics[width=1\columnwidth]{example-certificate.png} \\
    \end{tabular}
  \end{center}
\caption{\agr\ failure certificate for initial design.}
\label{fig:example-certificate}
\end{figure}

We focus on the software system for the UAV in this example.
%
The AADL architecture model for that system consists of two components as shown in \figref{fig:example}.
%
The first is the component for the automatic path planning for a mission (AI).
%
And the second is the component to meter the flight path waypoints to the actual UAV flight controller (WM).


From time to time, SW receives a message on the \texttt{AutomationRequest} input, forwarding it to the AI.
%
The function of AI is to compute the flight path (a list of waypoints) for the UAV, outputting the resulting \emph{mission command} on \texttt{AutomationResponse}.
%
The WM receives the mission command from AI and starts the UAV flying the mission by putting an \emph{event} on the \texttt{Start} output port, continuing to issue waypoints to the UAV flight controller on the \texttt{Waypoint} port as the UAV location updates with messages on \texttt{AirVehicleLocation}.
%
The AI component is third-party software and WM is a legacy component.

The expected behavior of the SW system, and the components implementing the system, are modeled with \agr\ contract specifications as shown by the unshaded boxes in the top-left of \figref{fig:workflow}.
%
These contracts assume and guarantee the absence of any malicious, or unspecified, component behavior.
%
More precisely, the contract for SW assumes that its inputs are \emph{well-formed} and that there is never more than one automation request pending at a time.
%
Well-formed generally refers to a syntactic restriction on data at a port. For example, a waypoint is well-formed if it falls within bounds for latitude, longitude, and altitude.
%
The guarantees for SW ensure that
\begin{compactitem}
\item a start coincides with a new waypoint being output;
\item a start is within one cycle of an automation request and if not, then it persistently alerts;
\item new waypoints coincide with location updates; and
\item all outputs are well-formed.
\end{compactitem}

The contracts for the sub-components assume their inputs are well-formed, and they guarantee their outputs are well-formed.
%
The AI contract guarantees it only responds to automation requests and always in the same cycle.
%
The legacy WM contract guarantees that
\begin{compactitem}
  \item it generates a start from a response from the AI and always in the same cycle;
  \item the start coincides with a waypoint; and
  \item any further waypoints coincide with location updates.
\end{compactitem}

\figref{fig:workflow} shows the intent of this behavioral contract definition of the UAV software system on the left-side of the figure at the arrow marked start.
%
The \agr\ verification engine tries to prove if the component composition of the software system is correct.
%
It is an iterative process where the designer updates contracts in the composition until \agr\ proves out the composition.
%
For our example, the initial specifications described above pass verification, meaning that the contract composition of the components with the system satisfies all component input assumptions and system output guarantees.
%
The \agr\ verification conditions, syntax and semantics, and the baseline contracts for the example are discussed in detail in \secref{sec:agree}.
%
\figref{fig:sw} in that section is the \agr\ contract for SW.

%%
% ADDING CYBER REQUIREMENTS
%%

\subsection{Adding cyber requirements}

Having passed \agr\ verification, the workflow in \figref{fig:workflow} proceeds to the threat analysis stage.
%
The UAV must actively protect itself from malicious actors, but to this point, the designers have only been focusing on its core functional behavior with little consideration for cyber-resilience.
%
A cyber-vulnerability analysis identifies the potential of a supply chain attack through the AI route planner since its third-party.
%
Based on the analysis, the designer adds a requirement that the system must guard against malicious AI behavior.
%
This requirement is reflected in the component contracts by removing all output guarantees from the AI contract since that component is considered untrusted.
%
Without output guarantees, the AI component is able to output arbitrary events in the \agr\ verification analysis.

The output from that analysis is shown in \figref{fig:example-certificate}.
%
The red exclamation points designate component assumptions or system output guarantees that do not hold, and each failure comes with a corresponding counter-example.
%
The first violation is that the mission command on \texttt{AutomationResponse} from the AI to the WM is no longer guaranteed to be well-formed: the red exclamation point on \emph{WM assume: Automation responses are well-formed}.
%
The consequence of that failing input assumption is that the WM outputs are no longer guaranteed.
%
For a contract, when an input assumption does not hold, then the output may be arbitrary.
%
The now arbitrary output from the WM due to input assumption violations lead to the rest of the failures in \figref{fig:example-certificate} as the WM provides the system level outputs.

\begin{figure*}
  \begin{center}
    \begin{tabular}{c}
      \includegraphics[width=2\columnwidth]{hardened.png}
    \end{tabular}
  \end{center}
  \caption{Cyber-hardened design for an automated UAV route planning system}
  \label{fig:hardened}
\end{figure*}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
      \includegraphics[width=\columnwidth]{agree-test-output.png} \\
      (a) \\ \\
      \includegraphics[width=\columnwidth]{hardened-certificate.png} \\
      (b)
    \end{tabular}
  \end{center}
  \caption{\agr\ verification certificates. (a) Test contract verification results. (b) Cyber-hardened design verification results.}
  \label{fig:hardened-certificate}
\end{figure}

%%
% ADDING HIGH ASSURANCE COMPONENTS
%%

\subsection{Adding high assurance components}

As \agr\ proves the system does not meet its cyber-requirements, the workflow moves to the right in \figref{fig:workflow} to the transforms box.
%
Here is where the shaded regions in \figref{fig:flowchart} come into play.
%
The system designer now uses \brfcs\ to cyber-harden SW by inserting high-assurance components in the form of a filter and a monitor, as shown in \figref{fig:hardened}.
%
These are intended to mitigate and report any observed malicious behavior by AI.

A filter enforces an invariant over each datum in the data stream by not forwarding input to its output if the invariant does not hold.
%
\brfcs\ generates an initial code contract for the filter which the designer completes by writing the invariant.
%
That invariant is usually based on the existing assumptions made by downstream components that consume the filter output.
%
In this example, it is the well-formed property for the automation request.

A monitor captures a relation on data over time and is thus able to reason about the temporal, and other invariant, properties of that data.
%
It raises an alert if the specified properties are ever violated.
%
As with the filter, \brfcs\ generates an initial code contract that is completed by the designer.
%
In this example, that contract states that an automation response can only be generated in conjunction with an automation request;
%
and further, that response must come with the request or in the next step after the request.
%
Code contracts are discussed in detail in \secref{sec:code-contracts}.
%
\figref{fig:filter} and \figref{fig:monitor} are the code contracts from that section for the high-assurance filter and monitor inserted into the original system as shown in \figref{fig:hardened}.

Code contracts for high assurance components can be arbitrarily complex since they can have persistent state that evolves over time.
%
Test contracts allow the designer to validate code contract behavior with unit testing.
For example, one of the test contracts for the monitor is that when it sees an automation response one step after a request, then it should not alert, and it should pass the response downstream.
%
Test contracts are discussed in detail in \secref{sec:testing}.
%
An example test from that section the the monitor in our example here is shown in \figref{fig:test}.


As shown in \figref{fig:workflow}, making the system cyber-resilient is an iterative process of adding high-assurance components, writing their code contracts, testing those contracts with test contracts, and then seeing if they are sufficient to prove out the system.
%
Having completed such an iterative for our example system, the \agr\ analysis of the cyber-hardened implementation is shown in \figref{fig:hardened-certificate}.
%
\figref{fig:hardened-certificate}(a) is the test contract results and \figref{fig:hardened-certificate}(b) is the hardened system composition.
%
Here \agr\ has generated high-level evidence justifying the claim that the high-assurance components meet their intended purposes.
%
Having passed \agr\ verification, the high-assurance components are ready to be synthesized.

%%
% SYNTHESIZING CODE FROM CODE CONTRACTS
%
\subsection{Synthesizing code from code contracts}

As \agr\ now proves the system now meets its cyber-requirements, the workflow moves to the right in \figref{fig:workflow} to the code generation box.
%
High-assurance components are automatically synthesized by \splt\ from the code contracts to equivalent programs in the \ckml\ language.
%
In other words, for any set of input streams that meet the component's contract assumptions, the output streams produced from the synthesized \ckml\ code exactly match those defined by the contract guarantees.

The synthesis algorithm is a sequence of semantics preserving transforms that refine the code contract to a step function over the inputs and current component state. The function computes the next state and outputs for the component at each scheduling step.
%
As such, the \agr\ verification results regarding the code contract apply equally to the synthesized \ckml, and thus, the results equally apply to the resulting binaries from the \ckml\ compiler.
%
Synthesis from code contracts is discussed in detail in \secref{sec:synthesis}.
%
\figref{fig:filter-cakeml} and \figref{fig:monitor-cakeml} are the implementations from that section for the high-assurance filter and monitor from our example here.


Extending the \agr\ verification results to the system composition requires additional guarantees not discussed here.
%
For example, among other things, contracts for non-synthesized components must be certified to accurately model their deployed counterparts, the generated scheduler must be certified to follow the dependent data-flow in the design, scheduling windows must be certified to cover worst-case execution times, \etc.
%
Such additional guarantees are discussed in other works \cite{gearcase2020, dcrypps2019, 10.1007/978-3-030-89159-6_18, 10.1007/978-3-030-89159-6_17, sel4-2009, nfm:agree, 9734792}.

Our discussion so far regarding the role of \agr\ in \brfcs\ in \figref{fig:flowchart}, and its expected workflow in \figref{fig:workflow}, has been high-level and abstract.
%
Indeed, we have only given a birdseye view of how \agr\ supports the verification of the system, code contracts, and test contracts, as well as how it provides the proof results that underpin our claim that the synthesized high-assurance components guarantee the \agr\ verification results.
%
In the following sections we delve into the details of \agr, including its notation, semantics, and usage, to set the stage for our primary contributions in \secref{sec:code-contracts}, \secref{sec:testing}, and \secref{sec:synthesis}.
%
For reference to where we discuss the actual contracts for the example system, \secref{sec:sw-contract} is the exposition of the \agr\ contract for the SW component, \secref{sec:ha-contracts} is the exposition of the code contracts for the high-assurance filter and monitor shown in \figref{fig:hardened}, and \secref{sec:testing} includes an exposition of a test contract for the monitor.

%%
% AGREE
%%

\section{\agr}
\label{sec:agree}

\newcommand{\globally}{\konst{Always}}
\newcommand{\historically}{\konst{Hist}}
\newcommand{\assumes}{\ensuremath{A}}
\newcommand{\guarantees}{\ensuremath{P}}
\newcommand{\inputs}{\ensuremath{I}}
\newcommand{\outputs}{\ensuremath{O}}
\newcommand{\components}{\ensuremath{C}}
\newcommand{\component}{\ensuremath{c}}

The \agr\ specification language, and semantics, are inspired by the Lustre language \cite{10.1145/41625.41641}.
%
Lustre semantics are synchronous data-flow where the inputs and outputs of components are streams.
%
Informally, streams assign values to expressions at each point in time.
%
\agr\ contracts express relationships between input and output streams by assuming a set of allowed input streams and then guaranteeing a corresponding set of allowed output streams.

%%
% COMPONENTS
%%

\subsection{Components}

A system implementation is described by its ports, its subcomponents, and the connections between ports on different subcomponents.
%
Ports in \agr\ are inherited from AADL.
%
There are three kinds of port: \emph{event} ports, \emph{data} ports, and \emph{event data} ports.
%
An event port carries no data and only signals occurrence (or not) of the event.
%
A data port is a sampled port: the data can be read at anytime.
%
An event data port indicates when data is present with an event.

Data flows through the subcomponents of a system in dependency order, with inputs being propagated to outputs through all contracts until they stabilize \ie, cannot propagate further.
%
Therefore, subcomponent contracts, and thus the top-level model, must be acyclic.
%
Cyclic systems are made acyclic by breaking cycles with delays.
%
Once the data propagation has stabilized, the model proceeds to the next input data in the input streams.
%
It is worth noting that the semantics do not model computation or communication delay: the output of one contract is seen at the input of any downstream contract in the same step of the input data stream.

%%
% CONTRACTS AND VERIFICATION CONDITIONS
%%

\subsection{Contracts and verification conditions}

From the system and component contracts, \agr\ generates a set of verification conditions to show that a system's component implementation is correct~\cite{agree2013}.
%
The \agr\ model checker is then invoked to prove or disprove the verification conditions.
%
The contracts and verification conditions are expressed in \emph{past-time linear temporal logic} (PLTL) \cite{10.1093/jigpal/8.1.55}.

PLTL is a logic enhanced with temporal operators able to reason about the truth values of formulas through time.
%
It combines past-time operators that reason over the history of computation up to a point (PTLTL) and future-time operators that reason over the computation that follows that point (LTL).
%
Its semantics are defined relative to a point in time $i$, a finite trace of system states $\pi = s_0, s_1, \ldots, s_i$, and some logic formula $f$.

The two PLTL operators necessary for the \agr\ generated verification conditions are $\globally$ that looks forward in time along the trace and $\historically$ (historically) that looks backward in time along the trace.
%
These are defined as
%
\begin{eqnarray*}
 (\pi, i) \models \globally(f) & \iff & \forall j \ge i, (\pi, j) \models f \\
(\pi, i) \models \historically(f) & \iff & \forall 0 \le j \le i, (\pi, j) \models f
\end{eqnarray*}
%
The $\models$-operator is read as \emph{satisfies}.
%
A trace at a moment in time satisfies $\globally(f)$ if and only if it satisfies $f$ in the current and all future states of $\pi$.
%
$\globally(f)$ is invariant from the current moment into the future and $\historically$ is invariant from the beginning of the trace to the current moment.

A \emph{system} is a tuple $(\inputs, \outputs, \assumes, \guarantees,C)$, where $\inputs$ is the input set, $\outputs$ is the output set, $\assumes$ is the set of assumptions, $\guarantees$ is the set of guarantees, and $C$ are subcomponents.
%
Assumptions and guarantees only use the past-time operators from PLTL.
%
A subcomponent $\component$ is, hierarchically, also a system, and may be designated by its own tuple $(\inputs_\component, \outputs_\component, \assumes_\component, \guarantees_\component, C_c)$.
%
From the components and their connections, $\mathbb{I}_\component$ is defined to be the set of components providing input to some component $\component$ in the system, and $\mathbb{O}$ is defined to be the set of components that provide the output for the system.

A system is \emph{correct} if and only if for all components $c \in C$ the following two verification conditions hold:
%
\begin{equation}\label{eq:assumes}
            \globally(\historically(\assumes \wedge
            \bigwedge_{\component^\prime \in \mathbb{I}_\component} P_{\component^\prime})
            \implies \assumes_\component)
\end{equation}
%
\begin{equation}\label{eq:guarantees}
            \globally(\historically(\assumes \wedge
            \bigwedge_{\component^\prime \in \mathbb{O}} \guarantees_{\component^\prime})
            \implies \guarantees)
\end{equation}
%
The conditions from \eqref{eq:assumes} verify the input assumptions on each component under the system assumptions and upstream component guarantees.
%
They check if the component guarantees and system assumptions are strong enough to imply input assumptions on all immediate downstream components.
%
The condition in \eqref{eq:guarantees} checks the output guarantees of the system under the system assumptions and component guarantees that provide the output.
%
It checks if the guarantees on components providing primary outputs are strong enough to imply the system guarantees.

If all the verification conditions hold (\agr\ uses $k$-inductive model checking to automatically prove or disprove each generated verification condition), then the system is said to be \emph{correct}, meaning that the system composition meets input assumptions at each input as well as the guarantees on the system output.
%
A consequence of this result is that $\globally(\historically(\assumes) \implies \guarantees)$ holds for the system contract.
%
Therefore the Liskov substitution principle applies and the implementation is a safe substitution for the system contract \cite{10.1145/62139.62141}.

The expanded property lists in \figref{fig:example-certificate} and \figref{fig:hardened-certificate} are the results from verifying or disproving the above verification conditions.
%
The additional unexpanded results at the bottom of the figures prove \emph{self-consistency} in the contracts.
%
A contract is self-consistent if it does not guarantee two different values in the same moment of time, \ie, the contract is not self-contradicting.
%
\agr\ generates additional verification conditions that prove each component contract, and the composition of contracts, self-consistent.

%%
% SYNTAX
%%

\subsection{Syntax}
\label{sec:agree-semantics}

The syntax of \agr\ is essentially that of quantifier-free first order predicate logic supplemented with a few temporal operators.
%
The terms (\emph{e}) are arithmetic expressions built from variables ($v$) and numeric and boolean literals ($c$), while formulas (\emph{b}) are built using logical connectives from atomic formulas (\emph{a}) based on the familiar comparison operators.
%
\[
\begin{array}{rcl}
e & ::= & v \mid c \mid e \;\set{+,*,/}\; e \\
a & ::= & e\; \set{=,<}\; e \\
b & ::= & v \mid c \mid a \mid \neg b
            \mid b \; \set{\land,\lor,\imp,\iff}\; b
\end{array}
\]
%
\agr\ includes a conditional, $\itelse{b}{(-)}{(-)}$, for both terms and formulas. To support port handling, \agr\ defines a predicate $\konst{event}(p)$, which tests if an event (or event-data) port $p$ is signaled.
%
Lastly, \agr\ supports temporal operators \emph{previously} $\konst{pre}(-)$, \emph{followed-by} $(-) \to (-)$, and historically $\konst{Hist}(-)$.

%%
% SEMANTICS
%%

\subsection{Semantics}

The semantics of terms and formulas is defined over \emph{streams of values}.
%
Values encompass at least booleans and numbers but can be readily extended to include records and arrays.
%
A value stream is a total function from time (natural numbers including 0) to values:
%
\[
 \konst{stream} = \mathbb{N}_0 \to \konst{value}
\]
%
Given an \emph{environment} $E : \konst{name} \mapsto \konst{stream}$ binding variable names to value streams, the semantics $\sem{-}^E_t$ of terms and formulas defines the meaning of compound syntax in terms of the meaning of subexpressions.
%
The value of a variable $v$ at time $t$ is found by looking up the stream bound to $v$ in $E$ (call it $s$) and returning $s_t$. Some clauses of the semantics follow, omitting the temporal operators:
%
\[
\begin{array}{rcl}
\sem{v}^E_t & = & E(v)(t) \\
\sem{c}^E_t & = & c \\
\sem{e_1 + e_2}^E_t & = & \sem{e_1}^E_t + \sem{e_2}^E_t \\
   & \cdots & \\
\sem{b_1 \land b_2}^E_t & = & \sem{b_1}^E_t \land \sem{b_2}^E_t \\
   & \cdots & \\
\end{array}
\]

The temporal operators deal with time in more significant ways.
%
The value of $\konst{pre}(e)$ at time $t$ is the value of $e$ at time $t-1$ (at time zero, \konst{pre} is undefined).
%
A followed-by, $e_1 \to e_2$, evaluates to $e_1$ at time zero; otherwise it is $e_2$.
%
Followed-by is typically used to give a value to a stream in the first step so that subsequent steps are able to use $\konst{pre}(e)$.
%
\[
\begin{array}{rcl}
\sem{\konst{pre}(e)}^E_t & = & \sem{e}^E_{t-1}, \mathrm{when}\ t > 0 \\
\sem{e_1 \to e_2}^E_t & = & \itelse{t=0}{\sem{e_1}^E_0}{\sem{e_2}^E_t} \\
\sem{\konst{Hist}(b)}^E_t & = & \forall n \leq t.\; \sem{b}^E_n
\end{array}
\]

Although basic, these definitions can be used to define higher-level past-time operators from PLTL such as \konst{Once} and \konst{Since}.
%
These can be expressed in a recursive style as follows:
%
\[
\begin{array}{rcl}
\konst{Once}(b) & = & b \to b \vee \konst{pre}(\konst{Once}(b)) \\
\konst{Since}(a, b) & = & b \to b \lor (a \land \konst{pre}(\konst{Since}(a, b))
\end{array}
\]
%
\noindent $\konst{Once}(b)$ is true if $b$ has ever been true before, or in, the current moment.
%
$\konst{Since}(a, b)$ is true if $a$ has been true in all moments up to the present one since $b$ most recently became true.
%
All other past-time operators of PLTL can be defined similarly \cite{monitor}.

\agr\ uses ASCII notation for the mathematical syntax we have defined.
%
The following table spells out the mapping.
%
\[
\begin{tabular}{l|l|l}
 Operation & Math. notation & \agr \\ \hline
 followed-by &  $e \to e$          & \verb+e -> e+  \\
 logical implication &  $e \imp e$ & \verb+e => e+ \\
 if-and-only-if &  $e \iff e$      & \verb+e <=> e+ \\
 logical and &  $e \land e$      & \verb+e and e+ \\
 logical or &  $e \lor e$      & \verb+e or e+ \\
 logical not & $\neg b$      & \verb+not b+ \\
 variable definition & $v = e$     & \verb+eq v e+ \\
 Previously  & $\konst{pre}(b)$ & \verb+pre(b)+ \\
 Historically  & $\konst{Hist}(b)$ & \verb+Historically(b)+ \\
\end{tabular}
\]

%%
% FORMAL CONTRACT FOR THE EXAMPLE SYSTEM
%%

\subsection{Formal contract for the example system}
\label{sec:sw-contract}

\newsavebox{\sw}
\begin{lrbox}{\sw}
\begin{lstlisting}[style=agree,numbers=left]
eq req : bool = event(AutomationRequest);*\label{line:sw-event-def-start}*
eq avl : bool = event(AirVehicleLocation);
eq wp  : bool = event(Waypoint);
eq strt: bool = event(Start);
eq alrt: bool = event(Alert);*\label{line:sw-event-def-end}*

assume "Automation requests are well-formed" : *\label{line:sw-assume-1}*
  req => WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
assume "Air vehicle locations are well-formed" : *\label{line:sw-assume-2}*
  avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);
assume "One automation request in flight at a time" : *\label{line:sw-assume-3}*
  true ->
  (req => pre(Historically(not req) or Since(not req, strt)));

guarantee "Waypoints coincide with air vehicle locations": *\label{line:sw-guarantee-1}*
  wp => avl;
guarantee "Starts include a new waypoint" : *\label{line:sw-guarantee-2}*
  strt => wp;
guarantee "Waypoints are well-formed" :  *\label{line:sw-guarantee-3}*
  wp => WELL_FORMED_WAYPOINT(Waypoint);
guarantee "Starts within one cycle of requests if not alerting" : *\label{line:sw-guarantee-4}*
  (strt => ((not alrt) and req)) ->
  (strt => ((not alrt) and (req or pre(req))));
guarantee "Alert if not started within one cycle of requests" : *\label{line:sw-guarantee-5}*
  true -> ((pre(req and not strt) and not strt) => alrt);
guarantee "Once alerted always alerted" : *\label{line:sw-guarantee-6}*
  Once(alrt) => alrt;
\end{lstlisting}
\end{lrbox}

\begin{figure}
  \begin{center}
    \scalebox{0.62}{\usebox{\sw}}
  \end{center}
  \caption{The SW component contract.}
  \label{fig:sw}
\end{figure}

The AGREE specification for the SW component in \secref{sec:example} is given in \figref{fig:sw}.
%
\linesref{line:sw-event-def-start}{line:sw-event-def-end} define local variables that are true when data is present on the corresponding event ports for the component.  These variables are
purely for notational convenience.
%
The contract has three assumptions:
%
\begin{itemize}
\item \lineref{line:sw-assume-1} and \lineref{line:sw-assume-2}.
When input is present it is well-formed. The well-formed predicates
are defined elsewhere using AGREE functions.
\item \lineref{line:sw-assume-3}. If there is an incoming request,
it is either the very first one, \texttt{\textbf{Historically}(\textbf{not} req)},
or it arrives after the component has output a start event in response to a previous
request, \texttt{\textbf{Since}(\textbf{not} req, strt)}---to be read as \emph{not
request since start}.
\end{itemize}

\noindent The contract has six guarantees:
%
\begin{itemize}
\item
\lineref{line:sw-guarantee-1}, \lineref{line:sw-guarantee-2}, and \lineref{line:sw-guarantee-3}.
%
A waypoint coincides with a update on the UAV location, a start coincides with a new waypoint, and waypoints are well-formed.

\item
\lineref{line:sw-guarantee-4}.
%
A start happens with a request or one step after a request.
%
At time zero the start must coincide with the request;
%
after that, the start must coincide with the request or else is a response to a request one step earlier.
%
The guarantee works with the assumption on \lineref{line:sw-assume-3} and thus does not have to check for two requests in a row without a start, since the assumption precludes that input behavior.
%
The guarantee also does not force the start to always happen, it only says that if it does happen, it is under the defined conditions.

\item
\lineref{line:sw-guarantee-5}.
%
The alert is signaled if the start does not arrive within the one-step bound.
%
Together with \lineref{line:sw-guarantee-4} this allows for non-alerting and alerting behavior.

\item
%
\lineref{line:sw-guarantee-6}.
%
If an alert has ever happened, it continues to happen.
\end{itemize}
%
These six guarantees define the behavior of the SW component under the three assumptions and correspond to the informal descriptions given in \secref{sec:example}.

\section{Code contracts for high assurance components}
\label{sec:code-contracts}
\input{high-assurance-contracts}

\section{Test contracts}
\label{sec:testing}
\input{testing}

\section{Synthesis to CakeML}
\label{sec:synthesis}
\input{synthesis}

\section{Case study}
\label{sec:case-study}
\input{case-study}

\section{Related work}
\label{sec:related-work}
\input{related-work}

\section{Conclusion}
\label{sec:conclusion}
\input{conclusion}

\clearpage
\bibliographystyle{plain}
\bibliography{paper}

\end{document}
