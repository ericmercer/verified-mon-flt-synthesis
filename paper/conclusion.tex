Safety critical systems, such as those found in avionics, must be cyber-resilient, i.e. tolerant to cyber-attacks, in the same way that they are fault tolerant. 
The \brfcs\ environment integrated into OSATE provides systems designers with tools to analyze and address cyber-vulnerabilities in the architectural design of a system modelled using AADL.
We have discussed transformations provided by \brfcs\ to insert, create, and synthesize high-assurance components such as filters and monitors to improve the cyber-resiliency of the system design.

A filter enforces invariant properties on data such that data that violate the invariant are not forwarded.
A monitor detects and alerts malicious behavior in the system. 
The actual behavior of such filters, monitors, and other high-assurance components are formally specified by code contracts.
A code contract is a (TODO: replace dialect with subset?) dialect of the \agr\ language with formal semantics embedded in HOL4 for formal reasoning.
A component's code contract states assumptions on the component inputs and provides guarantees that define the component outputs in terms of the component's inputs and current state.
The code contract language itself is Turing complete.

Code contracts are validated with unit tests that are verified with the \agr\ verification engine.
A unit test in expressed in a test contract in the \agr\ language.
A test contract is a stylized contract that strengthens the input assumptions of a code contract to a single input and either weakens or leaves unchanged the code contract output guarantees.
\agr\ then proves whether or not the computation expressed in the code contract (TODO: satisfies instead of implements?) implements the test contract.
In this way, a designer is able to test the behavior of the code contract.
Once the code contract is tested, the \agr\ verification engine proves whether or not the system, with the added high-assurance components, meets its cyber requirements.

Code contracts are automatically synthesized to \ckml.
We discussed the \splt\ synthesis engine that iteratively transforms the code contract defined over streams of data into a state transition function that only considers the current input and state of the component.
That state transition function is then rendered in \ckml, and the \ckml\ compiler compiles it to the target binary while also generating the proof of equivalence.

We demonstrated the viability of the approach in real-world industrial design by reporting a case study using the Air Force Research Laboratory's OpenUxAS software.
The study required a range of filters, monitors, and other mitigation components to meet cyber-requirements.
The case study demonstrated the viability of the approach to address complex message formats and non-trivial cyber-requirements.

The reported case study was carried out by those that created \brfcs\ with its several tools. 
Future work is to conduct another case study involving system designers unfamiliar with the \brfcs\ toolchain.
We have started such a study with the design of
an application using the Collins Common Avionics Architecture System
(CAAS)~\cite{caas} on the CH-47F Chinook helicopter program.
Early results are encouraging and are revealing ways to expand the expressiveness of the code contract language to make it easier to express iterative computation with arrays.

Aside from adding expressiveness to the code contract language, future work is to formally verify every transformation step from the code contract to the final \ckml\ function that is compiled to the target binary. 
The HOL4 embedding of the code contract semantics we have discussed is the starting point.
The key remaining steps are:
\begin{compactitem}
  \item Automatically add state to the code contract to remove $\konst{pre}(-)$ and prove the initial and modified contracts are equivalent for all input streams
  \item Create a step based version of the modified code contract that does not use streams and prove it equivalent to the stream version
  \item Create a pure HOL4 function, suitable to \ckml, from the step version of the code contract and prove it equivalent
\end{compactitem}
We have automated in HOL4 the transformation to remove $\konst{pre}(-)$ in the first step in what we call \emph{temporal squashing}.
We have additionally written proofs (manually) for every step for a set of example code contracts.
From the manual proofs, we have started work on proofs for the first two steps.
Since these two steps are universal to all input code contracts their proofs need to be generated just once (as opposed to generating them for every component contract).
%are universal in that they reason over any input code contract.
The proof for the third step must be generated for each input contract. Finally, the entire process needs to be mechanized.
Other future work includes lifting the proof results to infinite streams.
