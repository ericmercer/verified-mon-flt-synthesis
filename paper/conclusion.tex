Safety critical systems, such as those found in avionics, must be cyber-resilient in the same way that they are fault tolerant. 
Cyber-resiliency means that they are tolerant to cyber-attacks.
The \brfcs\ environment integrated into OSATE provides systems designers with tools to analyze and address cyber-vulnerabilities in the AADL architecture design of a system.
We discussed here transformations provided by \brfcs\ to insert, create, and synthesize high-assurance components such as filters and monitors to improve the cyber-resiliency of the system design.

A filter enforces invariant properties on data such that data that violate the invariant are not forwarded.
A monitor detects and alerts malicious behavior in the system. 
The actual behavior of such filters, monitors, and other high-assurance components are formally specified by code contracts.
A code contract is a dialect of the \agr\ language with formal semantics embedded in HOL4 for formal reasoning.
A code contract states assumptions on the inputs and then provides output guarantees that completely define the output in terms of the inputs and the current state of the component.
The code contract language itself is Turing complete.

Code contracts are validated with unit tests that are verified with the \agr\ verification engine.
A unit test in expressed in a test contract in the \agr\ language.
A test contract is a stylized contract that strengthens the input assumptions of a code contract to a single input and either weakens or leaves unchanged the code contract output guarantees.
\agr\ then proves whether or not the computation expressed in the code contract implements the test contract.
In this way, a designer is able to test the behavior of the code contract.
Once the code contract is tested, the \agr\ verification engine proves whether or not the system, with the added high-assurance components, meets its cyber requirements.

Code contracts are automatically synthesized to \ckml.
We discussed the \splt\ synthesis engine that iteratively transforms the code contract defined over streams of data into a state transition function that only considers the current input and state of the component.
That state transition function is then rendered in \ckml, and the \ckml\ compiler compiles it to the target binary providing the proof of equivalence.

We further demonstrated the viability of the approach in real-world industrial design by reporting a case study using the Air Force Research Laboratory's OpenUxAS software.
The study required a range of filters, monitors, and other mitigation components to meet cyber-requirements.
The case study demonstrated the viability of the approach to address complex message formats and non-trivial cyber-requirements.

The reported case study was carried out by those that created \brfcs\ with its several tools. 
Future work is to conduct another case study involving system designers.
We have started such a study with the design of
an application using the Collins Common Avionics Architecture System
(CAAS)~\cite{caas} on the CH-47F Chinook helicopter program.
Early results are encouraging and are revealing ways to expand the expressiveness of the code contract language to make it easier to express iterative computation with arrays.

Aside from adding expressiveness to the code contract language, future work is to formally verify every transformation step from the code contract to the final \ckml\ function that is compiled to the target binary. 
The HOL4 embedding of the code contract semantics we discussed here is the starting point.
The key steps are as follows:
\begin{compactitem}
  \item Automatically add state to the code contract to remove $\konst{pre}(-)$ and prove the initial and modified contracts are equivalent for all input streams
  \item Create a step based version of the modified code contract that does not use streams and prove it equivalent to the stream version
  \item Create a pure HOL4 function, suitable to \ckml, from the step version of the code contract and prove it equivalent
\end{compactitem}
We have automated in HOL4 the transformation to remove $\konst{pre}(-)$ in the first step in what we call \emph{temporal squashing}.
We have additionally manually written proofs for every step for a set of example code contracts.
From the manual proofs, we have started work on proofs for the first two steps that are universal in that they reason over any input code contract.
The third step must be generated for each input contract, and the entire process still needs to be mechanized.
Other future work includes lifting the proof results to infinite streams.
