Writing and proving properties about AGREE specifications is hard not just because it is a formal process but  because it reasons about constraints that define the entire input space for a component, and the entire output space, at once.
The case studies showed that engineers, and formal method practitioners, make mistakes writing these specifications especially if the computation or temporal reasoning is complex.
It is difficult to reason about the whole of the specification to understand the defined behavior of a component or system.
A natural consequence of this inherent complexity is that the AGREE analysis proves out, but that proof is about a flawed specification.
The AGREE analysis, and synthesized component, is only as good as the specifications.
As the saying goes, \emph{garbage in means garbage out}.

The case studies found four common mistakes in specifications: contradictions, vacuity, under-specification, and missed corner cases.
Contradictions arise from inconsistent contracts that state conflicting constraints in any given moment invalidating the verification results: a property can be proved true and it can be proved false.
Vacuity is a common pitfall with implication when the left hand side is always false making the implication true. 
Vacuity is referred to as the \emph{block of wood} problem because a system that does nothing passes verification with implications.

Under-specification is very challenging because verification is not able to prove anything (or it can prove everything in the case of existential properties) so nothing is actually known after verification except that the system is under-specified. 
The tell-tale symptom of underspecification is that AGREE verification is not able to prove anything about a property: it is not true and it is not false.
The property stated in the positive fails and the property stated in the negative fails.
Missed corner cases is a common problem to all disciplines.
It is especially hard here because there is no easy way break down, and check, specifications in a case by case input analysis.

AGREE already detects, and reports, contradicting and inconsistent contracts, but it does not check for vacuity and under-specification, and missed corner cases is always an issue.
The case studies navigated these challenges by writing a specification, synthesizing it to code with SPLAT, and then running unit 
tests on the synthesized code in a testing harness.
The synthesized code is known to precisely capture the meaning of the specification, so the tests directly reflect the behavior of the specification in much the same way as compiled code is assumed correct.
The designers are then able to iteratively test and refine the specifications into a final form.
The process is inefficient, requires an additional, unneeded, test harness, the code is proved correct by SPLAT after all, and steps outside the MBE environment using the implementation, rather than the model, to analyze and understand the system model.

There needs to be a bridge between the formal model in AGREE with its proof of system properties and more traditional reasoning with test that is a well established method for building assurance.
Classical black-box and white-box test coverage should be, and are, equally applicable to formal reasoning as traditional engineering in regards to developing, and eventually proving, the correctness of a specification.
AGREE is able to provide such a testing framework.

Unit tests are created in AGREE by writing a system specification that assumes the test input and then guarantees the test output.
The system is then implemented with the component under test and its specification.
The AGREE analysis then proves if the component guarantees, given the test inputs, are strong enough to prove the guaranteed test outputs.
Here the system assumptions strengthen the component assumptions to a single input, and the system guarantees weaken, or leave unchanged, the component output for that test input, depending on the goal of the test.
AGREE proves the component implements the test, and the Liskhov substitution principle holds.

\newsavebox{\tst}
\begin{lrbox}{\tst}
  \begin{lstlisting}[style=agree,numbers=left]
    process should_notAlertAndOutput_when_responseOneStepAfterRequest
      ... -- Omitted AADL features
      annex agree {**
        eq index : int = prev(index + 1, 0); *\label{line:tst-index}*
        
        assume "One Response one step after Request" : *\label{line:tst-assume-1}*
                ((index = 0) => not event(Response))
            and ((index = 1) => event(Response))
            and ((index >= 2) => not event(Response));
        assume "One Request" : *\label{line:tst-assume-2}*
            (event(Request) = true) ->
            (event(Request) = false);
        
        guarantee "Not Alert" : *\label{line:tst-guarantee-1}*
            not event(Alert);
        guarantee *\label{line:tst-guarantee-2}*
          "Output one step after Request at same time as Response" :
                ((index = 0) => not event(Output))
            and ((index = 1) => (event(Output) and Output = Response))
            and ((index >= 2) => not event(Output));
      **};
    end should_notAlertAndOutput_when_responseOneStepAfterRequest;
    
    process Implementation *\label{line:tst-imp-start}*
      should_notAlertAndOutput_when_responseOneStepAfterRequest.test
      subcomponents
        Monitor: thread CASE_Monitor_Thr.Impl; *\label{line:tst-imp-comp}*
      connections
        c00: port Response -> Monitor.Response;
        c01: port Request -> Monitor.Request;
        c02: port Monitor.Alert -> Alert;
        c03: port Monitor.Output -> Output;
    end should_notAlertAndOutput_when_responseOneStepAfterRequest.test; *\label{line:tst-imp-end}*
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
    \scalebox{0.62}{\usebox{\tst}} \\
    \end{tabular}
  \end{center}
  \caption{AGREE Unit test for high-assurance monitor.}
  \label{fig:test}
\end{figure}

\figref{fig:test} is a unit test for the high-assurance monitor in \figref{fig:hardened}.
The test checks if the monitor output coincides with the response that comes one step after the request.
It also checks that the alarm does not fire.
\lineref{line:tst-index} creates an index to use to create the test input.
\lineref{line:tst-assume-1} defines when the response appears relative to the index.
\lineref{line:tst-assume-2} defines the request behavior.
\linesref{line:tst-guarantee-1}{line:tst-guarantee-2} define the expected test output.
The test additionally proves that nothing happens after the initial test input and output (e.g., no more input is provided and no more output is generated).
AGREE proves the test correct.
\linesref{line:tst-imp-start}{line:tst-imp-end} implement the system using the component (\lineref{line:tst-imp-comp})

This AGREE test method is effective for detecting vacuity, under-specified behavior, and missed corner cases.
It enables designers to iteratively develop specifications inside the MBE framework using AGREE, and it builds assurance that the specification reflects the desired behavior with black-box, white-box, and other test coverage metrics.
These same tests can be synthesized to the backend implementation for traditional testing.

Traditional testing is important for the implementations of components that are not high-assurance.
The behavior of regular components must be modeled in AGREE since they are part of any system implementation, and their specifications provide input to high-assurance components.
Like the high-assurance components, these specifications must be meaningful in modeling the representative component.
Testing is an effective means for validating such specifications, and AGREE can use the existing tests from the component implementation to check the specifications, and it can generate additional tests that probe the behavior of the component implementation when writing the specifications.