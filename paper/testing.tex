Writing and proving properties about code contracts is difficult because it is a formal process, and because it reasons about constraints that define the entire input space, and the entire output space, of a high-assurance component at once.
Case studies have shown that designers, as well as formal method practitioners, make mistakes writing these contracts, especially if the computation or temporal reasoning in the contract is complex.

We have observed three common types of mistakes in code contracts (aside from self-consistency, which is
already checked): vacuity, under-specification, and missed corner cases.
Vacuity is a common pitfall with implication when the left hand side is always false, making the implication true. 
Under-specification is very challenging, as \agr\ is not able to prove anything (or it can prove everything in the case of existential properties), so nothing is actually known after verification except that the contract is under-specified. 
Missed corner cases is a common problem to all disciplines.
It is an especially difficult challenge here because there is no direct way to exercise code contracts, \eg, there is no runtime \emph{per se}.

A tempting approach to exercising code contracts directly is to use \splt\ to create the target binary and then use that runtime with traditional testing.
Such an approach adds extra steps, including test harneses, that are not needed, as it is
possible to bridge the formal model in \agr, with its proof system, to
traditional validation using tests.
The intuition for that bridge comes from the compositional reasoning in AADL and \agr. 
Effectively, a code contract for a high assurance component should be a valid implementation of a test scenario.
In other words, the test scenario, as expressed in a test contract, is the desired behavior of the system, and the code contract implements that behavior.

A test contract defines the test scenario for the code contract to implement.
It does this by assuming the test input and guarantying the test output akin to a unit test. 
The code contract is used as the implementation, \eg, it is the test subject.
The \agr\ analysis then proves if the code contract, given the test inputs, is strong enough to prove the test contract outputs.
Here the test contract assumptions strengthen the code contract assumptions to a single input, and the test contract guarantees weaken, or leave unchanged, the code contract output for that test input, depending on the goal of the test.
In other words, according to Liskov substitution, \agr\ proves if the code contract is a safe substitution for the test contract.

\newsavebox{\tst}
\begin{lrbox}{\tst}
  \begin{lstlisting}[style=agree,numbers=left]
    process should_notAlertAndOutput_when_responseOneStepAfterRequest
      ... -- Omitted AADL features
      annex agree {**
        eq index : int = prev(index + 1, 0); *\label{line:tst-index}*
        
        assume "One Response one step after Request" : *\label{line:tst-assume-1}*
                ((index = 0) => not event(Response))
            and ((index = 1) => event(Response))
            and ((index >= 2) => not event(Response));
        assume "One Request" : *\label{line:tst-assume-2}*
            (event(Request) = true) ->
            (event(Request) = false);
        
        guarantee "Not Alert" : *\label{line:tst-guarantee-1}*
            not event(Alert);
        guarantee *\label{line:tst-guarantee-2}*
          "Output one step after Request at same time as Response" :
                ((index = 0) => not event(Output))
            and ((index = 1) => (event(Output) and Output = Response))
            and ((index >= 2) => not event(Output));
      **};
    end should_notAlertAndOutput_when_responseOneStepAfterRequest;
    
    process Implementation *\label{line:tst-imp-start}*
      should_notAlertAndOutput_when_responseOneStepAfterRequest.test
      subcomponents
        Monitor: thread CASE_Monitor_Thr.Impl; *\label{line:tst-imp-comp}*
      connections
        c00: port Response -> Monitor.Response;
        c01: port Request -> Monitor.Request;
        c02: port Monitor.Alert -> Alert;
        c03: port Monitor.Output -> Output;
    end should_notAlertAndOutput_when_responseOneStepAfterRequest.test; *\label{line:tst-imp-end}*
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
    \scalebox{0.60}{\usebox{\tst}} \\
    \end{tabular}
  \end{center}
  \caption{A unit test for the monitor with its test contract.}
  \label{fig:test}
\end{figure}

\figref{fig:test} is a unit test, with its test contract, for the monitor in \figref{fig:hardened}.
The test contract checks if the monitor output coincides with the response that comes one step after the request.
It also checks that the alarm is not output.
\begin{compactitem}
\item \lineref{line:tst-index}: An index to use to define the test input and expected test output through time.
\item \lineref{line:tst-assume-1} and \lineref{line:tst-assume-2}: The test input. These define when the request and response message events should appear relative to the index.
\item \lineref{line:tst-guarantee-1} and \lineref{line:tst-guarantee-2}: The expected test output. 
The test additionally proves that nothing happens after the initial test input and expected output, \ie, no more input is provided and no more output is generated.
\item \linesref{line:tst-imp-start}{line:tst-imp-end}: The implementation with the component under test (\lineref{line:tst-imp-comp}).
\end{compactitem}
\figref{fig:hardened-certificate}(a) is the \agr\ output for the test showing that it passes. 

Test contracts are effective in detecting vacuity, under-specified behavior, and missed corner cases.
They enable designers to iteratively develop code contracts inside OSATE with \agr, and they build assurance that the code contract computes the desired behavior with black-box, white-box, and other test coverage metrics.
These same tests can be synthesized to the backend implementation for traditional testing, if for example, the code contract is a model of an existing legacy binary.