In this section we give an overview of the AGREE semantics, a
machine-checked formal definition of the meaning of AGREE expressions,
formulas, and contracts. The semantics supports a formal connection
between the results of the AGREE model checker and code generated from
specifications of leaf level cyber-components. It also provides the root
meaning at the base of a chain of translation steps moving from AGREE
specifications to CakeML executables.


\subsection{AGREE syntax and semantics}
\label{agree-semantics}

The syntax of AGREE is essentially that of quantifier-free first order
logic (FOL) supplemented with a few temporal operators. The terms
(\emph{e}) are the usual arithmetic expressions built from variables
and numeric literals, while formulas (\emph{b}) are built using the
standard logical connectives from atomic formulas (\emph{a}) based on
the usual comparison operators.
\[
\begin{array}{rcl}
e & ::= & v \mid c \mid e \;\set{+,*,/}\; e \\
a & ::= & e\; \set{=,<,\leq}\; e \\
b & ::= & v \mid c \mid a \mid \neg b
            \mid b \; \set{\land,\lor,\imp,\iff}\; b
\end{array}
\]

There is a conditional, $\itelse{b}{(-)}{(-)}$, for both terms and
formulas. There are also temporal operators $\konst{pre}(-)$, delay
$(-) \to (-)$, and $\konst{Hist}(-)$.

The semantics of terms and formulas is in terms of \emph{streams of
values}. Values encompass at least booleans and numbers, but can be
readily extended to include records and arrays. A value stream is a
total function from natural numbers to values:
\[
 \konst{stream} = \mathbb{N} \to \konst{value}
\]
Given an \emph{environment} $E : \konst{name} \mapsto \konst{stream}$
binding variable names to value streams, the semantics $\sem{-}$ of terms and
formulas, omitting temporal operators, is standard.

\[
\begin{array}{rcl}
\sem{v}_t & = & E(v)(t) \\
\sem{c}_t & = & c \\
\sem{e_1 + e_2}_t & = & \sem{e_1}_t + \sem{e_2}_t \\
   & \cdots & \\
\sem{b_1 \land b_2}_t & = & \sem{b_1}_t \land \sem{b_2}_t \\
   & \cdots & \\
\end{array}
\]

The temporal operators deal with time in more significant ways:
\[
\begin{array}{rcl}
\sem{\konst{pre}(e)}_t & = & \sem{e}_{t-1}, \mathrm{when}\ t > 0 \\
\sem{e_1 \to e_2}_t & = & \itelse{t=0}{\sem{e_1}_0}{\sem{e_2}_t} \\
\sem{\konst{Hist}(b)}_t & = & \forall n \leq t.\; \sem{b}_n
\end{array}
\]

\subsubsection{Extracting computation from specification}

A subtle aspect of our approach is that AGREE does not explicitly
present the computation that a component performs. This is entirely
appropriate since AGREE is intended to reason about components solely
at the specification level. However, specifications do support state
variables, and updates to them; consequently---for inserted leaf-level
security components---SPLAT interprets sequences of variable
assignments as specifying the computation of the component.

\begin{itemize}
\item \textit{Point to discussion on output code guarantees}

\item \textit{code contract representation}

\item \textit{strmStep}

\item \textit{Contract semantics}

\item \textit{How example looks}
\end{itemize}
