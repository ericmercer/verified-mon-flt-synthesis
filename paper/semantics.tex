The semantics supports a formal connection between the results of the
AGREE model checker and code generated from specifications of leaf
level cyber-components. It also provides the root meaning at the base
of a chain of translation steps moving from AGREE specifications to
CakeML executables.

Code generation is a multi-step transformation that starts with a code
contract and ends with an executable. The first step maps the contract
to a code-focused representation. Assume given code contract
$(I,O,A,\mathit{Eqs} \cup G \cup P)$, environment $E$, and time
$t$. The evaluation of $\mathit{Eqs}$ followed by the evaluation of
$G$ results in a new environment $E'$ where the stream values for
state variables and outputs have been computed for time $t$. The step
from $E$ to $E'$ is one full cycle in the repeated evaluation of the
component.

\begin{definition}[Evaluation]
We overload existing notation and write the evaluation of
$\mathit{Eqs}$ and then $G$ in environment $E$ at time $t$ as
$\sem{\mathit{Eqs}\cdot G}^E_t$. Each $v = e \in {\Eqs}$ is treated as
an environment transformation
\[
 \sem{v = e}^E_t = E[v(t) \mapsto\sem{e}^E_t] \ .
\]
modifying $E$ so that stream $v$ has value $\sem{e}^E_t$ at time $t$.
{\Eqs} is evaluated by folding the transformation left-to-right
through it. The transformation is also applied to the list of output
guarantees $G$, computing the values on output ports. The details are
omitted, being a bit messy because of the different kinds of output
ports available.
\end{definition}


\begin{definition}[Code contract correctness]
Assume given code contract $(I,O,A,\mathit{Eqs} \cup G \cup P)$ and
environment $E$.  The contract is \emph{correct}, if for all $t$,
whenever the assumptions (historically) hold in $E$ and evaluation
steps from $E$ to $E'$, then the guarantees hold in $E'$:
\[
\sem{\konst{Hist}(A)}^E_t \land E' = \sem{\mathit{Eqs} \cdot G}^E_t \imp \sem{P}^{E'}_t
\]
\end{definition}
\footnote
{KLS: At this point we would like to assert that the AGREE ``consistency
 check'' for a contract implies code contract correctness.}

The evaluation semantics given above is based on the stream
computation model, where values `deep in the past' can be accessed in
computations. However, the conventional program languages we wish to
target do not support such a view. Thus code generation is only
defined for a class of \emph{well formed} equations.

\begin{definition}[Wellformedness]

\end{definition}

\subsubsection{Example}
