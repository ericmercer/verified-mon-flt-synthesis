%% \begin{figure}
%%   \begin{center}
%%     \begin{tabular}{c}
%%     \includegraphics[scale=0.3]{dialogue.png}
%%     \end{tabular}
%%   \end{center}
%%   \caption{BriefCASE dialogue for filter transformation.}
%%   \label{fig:dialogue}
%% \end{figure}

\subsection{Code contracts}
\label{code-contracts}

Generally, AGREE specifications do not describe the computation that a
component performs. This is entirely by design: AGREE is intended to
reason about component behavior solely at the specification
level. However, the syntax of AGREE specifications provides enough
expressiveness to support the notion of a \emph{code contract}: a
contract from which an implementation can be extracted. First we must
discuss a class of guarantees---\emph{output guarantees}---which
determine the values on all output ports of a component.

\begin{definition}[Output guarantee]
An \emph{output guarantee} is a stylized guarantee that fully
specifies the data written to an output port. There are three
possibilities according to whether the output port $p$ is
a \konst{data} port, an \konst{event} port, or an \konst{event data}
port:
\[
\begin{array}{ll}
\konst{data}: &  p = \mathit{e} \\
\konst{event}: &  \konst{event} (p) = \mathit{b} \\
\konst{event data}: & \itelse{b}{\konst{event} (p) \land p = e}{\neg \konst{event}(p)} \\
\end{array}
\]
\end{definition}

Informally, a code contract treats its \konst{eq} ``statements'' as
defining a list of assignments to state variables, and its output
guarantees as directives for producing output.

\begin{definition}[Code contract] A
  leaf component of the form $(I,O,A,P,\emptyset)$ is a
  \emph{code contract} if $\mathit{Eqs} \cup G \subseteq P$, where
\[\mathit{Eqs} = \set{v_1 = e_1, \cdots , v_n = e_n} \] is a non-empty set
of \konst{eq} statements and $G$ is the set of output guarantees, one for
each element of $O$. In the interpretation as code, the order of
elements of $\mathit{Eqs}$ is important, and is simply taken to be the
occurrence order of the \konst{eq} statements in the syntax. Thus we
will work with the
\emph{list} of equations $\mathit{Eqs} = [v_1 = e_1; \cdots ; v_n = e_n]$.
\end{definition}


The semantics of Section \ref{agree-semantics} supports a formal
connection between the original contract (and verification results of
the AGREE model checker being run on it), and code generated from
specifications of leaf level cyber-components. It also provides the
root meaning at the base of a chain of translation steps moving from
AGREE specifications to CakeML executables.

The first step in the chain maps the contract to a code-focused
representation. Assume given code contract $(I,O,A,\mathit{Eqs} \cup G \cup
P,\emptyset)$, environment $E$, and time $t$. The evaluation of $\mathit{Eqs}$
followed by the evaluation of $G$ results in a new environment $E'$
where the stream values for state variables and outputs have been
computed for time $t$. The step from $E$ to $E'$ is one full cycle in
the repeated evaluation of the component.

\begin{definition}[Evaluation]
We overload existing notation and write the evaluation of
$\mathit{Eqs}$ and then $G$ in environment $E$ at time $t$ as
$\sem{\mathit{Eqs}\cdot G}^E_t$. Each $v = e \in {\Eqs}$ is treated as
an environment transformation
\[
 \sem{v = e}^E_t = E[v(t) \mapsto\sem{e}^E_t] \ .
\]
modifying $E$ so that stream $v$ has value $\sem{e}^E_t$ at time $t$.
{\Eqs} is evaluated by folding the transformation left-to-right
through it. The transformation is also applied to the list of output
guarantees $G$, computing the values on output ports. The details are
omitted, being a bit messy because of the different kinds of output
ports available.
\end{definition}


\begin{definition}[Code contract correctness]
Assume code contract $(I,O,A,\mathit{Eqs} \cup G \cup P,\emptyset)$.
The contract is \emph{correct}, if for all $E$ and $t$, whenever the
assumptions (historically) hold in $E$ and evaluation steps from $E$
to $E'$, then the guarantees hold in $E'$:
\[
\sem{\konst{Hist}(A)}^E_t \land E' = \sem{\mathit{Eqs} \cdot G}^E_t \imp \sem{P}^{E'}_t
\]
\end{definition}
\footnote
{KLS: At this point we would like to assert that the AGREE ``consistency
 check'' for a contract implies code contract correctness.}

How does this notion of correctness integrate with the verification
conditions addressed by model checking? In \emph{contract
correctness}, the model checker is proving the following property
\[
\konst{Hist}(A) \imp P
\]
and in \emph{code contract correctness} we essentially prove a Hoare
triple of the form
\[
\set{\konst{Hist}(A)}\; (\mathit{Eqs} \cdot G) \; \set{P}
\]
This accords with intution, namely that AGREE is a kind of
`program-free program logic'; by pulling out a program $(\mathit{Eqs}
\cdot G)$ from a code contract we find ourselves in the tepid
bathwater of imperative program verification. In order to use the code
contract result in system contract verifcation conditions, one has to
show that the code contract result implies the system verification
condtion.

\subsubsection*{Wellformedness}
The evaluation semantics given above is based on the stream
computation model, where values `deep in the past' can be accessed in
computations. However, the conventional program languages we target
target do not support such a view. Thus code generation is only
defined for a class of \emph{wellformed} equations.

\begin{definition}[Wellformedness]
\end{definition}

\subsection{Code contracts for the hardened system}

\newsavebox{\flt}
\begin{lrbox}{\flt}
  \begin{lstlisting}[style=agree,numbers=left]
    -- start user definitions
    eq policy : bool =
      WELL_FORMED_AUTOMATION_RESPONSE(Input);
    -- stop user definitions

    guarantee "Filter output is well-formed" :
      if event(Input) and policy then
        event(Output) and Output = Input
      else
        not event(Output);
  \end{lstlisting}
\end{lrbox}

\newsavebox{\mntr}
\begin{lrbox}{\mntr}
  \begin{lstlisting}[style=agree,numbers=left]
    const is_latched : bool = true;

    -- start user definitions
    assume "One automation request in flight at a time" : *\label{line:mon-assume}*
      true -> (req => pre(Historically(not req) or Since(not req, rsp)));

    const MAX_LATENCY : int = 1; *\label{line:mon-const}*

    eq rsp : bool = event(Response);
    eq req : bool = event(Request);

    eq isPending : bool = Since(not rsp, req and not rsp);*\label{line:mon-pending}*
    eq latency : int = 0 -> (if req then 0 else pre(latency) + 1);*\label{line:mon-latency}*

    eq policy : bool = (rsp => req) ->
                         (    (isPending => latency < MAX_LATENCY)
                          and (rsp => (req or pre(isPending))));
    *\label{line:mon-policy}*
    -- stop user definitions

    eq alert : bool = (not policy) -> *\label{line:mon-alert}*
                        ((is_latched and pre(alert)) or not policy);

    guarantee "Alert port tracks alert variable" :
      event(Alert) = alert;
    guarantee "Output if not alerted" :
      if (not(alert) and rsp) then
          event(Output) and (Output = Response)
      else
          not (event(Output));
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
      \scalebox{0.62}{\usebox{\flt}} \\
    \end{tabular}
  \end{center}
  \caption{Code contract specification for high-assurance filter.}
  \label{fig:filter}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
    \scalebox{0.62}{\usebox{\mntr}} \\
    \end{tabular}
  \end{center}
  \caption{Code contract specification for high-assurance monitor.}
  \label{fig:monitor}
\end{figure}


As previously discussed, transformations carried out in the BriefCASE
interface have created a cyber-hardened system, protecting against
malicious AI behavior, by inserting a high-assurance filter and
monitor between the AI and the WM (see \figref{fig:hardened}). The
filter protects the WM from malformed data and the monitor protects
the WM from (possibly malicious) spontaneous or delayed responses.
These components were added, one at a time, by
\begin{enumerate}
  \item selecting the connection in the model where the
    component is to appear,
  \item choosing the appropriate transformation, and
  \item specifying the relevant filtering or monitoring \emph{policy} (behavior).
\end{enumerate}

%% The system designer provides configuration parameters for the
%% transformation in a dialogue box.  The dialogue box for adding a
%% filter is shown in \figref{fig:dialogue}.  All high-assurance
%% components rely on a \emph{policy} to define behavior as seen in the
%% last field of the dialogue box.  A filter policy defines well-formed
%% data while a monitor policy defines an invariant over inputs and
%% outputs.  These policies can be stated directly in the wizard, or they
%% can be left blank and added later to the AGREE contract generated by
%% the transformation.

BriefCASE creates all the needed AADL for the new high-assurance
component, and its connections in the system implementation, as part
of the transformation.  It also creates a default AGREE specification
that defines everything about the component behavior, leaving only the
component behavior (policy) to be specified.


Code contracts for the filter and monitor are shown in
\figref{fig:filter} and \figref{fig:monitor}.\footnote{KLS: do we discuss wellformedness anywhere?} In general, the
\konst{eq}-statements of a code contract keep track of
state and provide data values from which to compute values to place on
the outputs.

\subsubsection{Monitor specification}
BriefCASE generates everything but the
\konst{eq}-statements in \linesref{line:mon-assume}{line:mon-policy} of
\figref{fig:monitor}.  As with the filter, the guarantees
completely define the output, as required for synthesis, in terms of
the policy and the alert.  The
\texttt{alert} variable defined on \lineref{line:mon-alert} depends
not just on the policy but also on configuration details supplied when
the component is specified.  At configuration
time, \texttt{is\_latched} has been set to \konst{true}, thus making
the alert persistent, meaning that once the alert is raised, it is
always raised; otherwise, it is the complement of the policy value in
the current step.

The monitor policy is defined by marking when a request is not
satisfied, \texttt{isPending} on \lineref{line:mon-pending}, and
counting the number of steps between requests, \texttt{latency} on
\lineref{line:mon-latency}.  The \texttt{isPending} variable is true
whenever there is a request that does not coincide with a
response--\emph{not response since request and not response}.  The
\texttt{latency} variable starts at zero, resets on every request, and
otherwise increments by one.

The latency bound for the monitor is defined by the constant
\texttt{MAX\_LATENCY} on \lineref{line:mon-const}.  Here the constant
is set to one to be consistent with the system specification from the
previous section.  At time 0 the policy is trivial: a response
requires an accompanying request.  After time 0, if a request is
pending in the current time step, then the latency must still be under
the bound, and if there is a response, then it closes a request now or
a pending request from earlier in time.

The policy definition only works if there is never more than one
outstanding request at a time; otherwise, the latency counter resets
incorrectly.  That requirement is encoded in the assumption on
\lineref{line:mon-assume} and is the same assumption used for the
system input.  The policy can be written without needing the
assumption, but it is much simpler to write with the assumption.

As shown in \figref{fig:hardened-certificate}, the cyber-hardened
system passes AGREE verification.  That means that the high-assurance
components protect the WM from the untrusted AI generating malformed
data, spontaneous responses, or delayed responses.  Synthesis must
generate precise implementations of the high-assurance component
specifications for the AGREE verification result to apply to the
deployed system.  Precise in this context means that the
implementations match the input to output relations defined in the
specifications.
