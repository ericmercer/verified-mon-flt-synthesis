%% \begin{figure}
%%   \begin{center}
%%     \begin{tabular}{c}
%%     \includegraphics[scale=0.3]{dialogue.png}
%%     \end{tabular}
%%   \end{center}
%%   \caption{BriefCASE dialogue for filter transformation.}
%%   \label{fig:dialogue}
%% \end{figure}

\newsavebox{\flt}
\begin{lrbox}{\flt}
  \begin{lstlisting}[style=agree,numbers=left]
    -- start user definitions
    eq policy : bool =
      WELL_FORMED_AUTOMATION_RESPONSE(Input);
    -- stop user definitions

    guarantee "Filter output is well-formed" :
      if event(Input) and policy then
        event(Output) and Output = Input
      else
        not event(Output);
  \end{lstlisting}
\end{lrbox}

\newsavebox{\mntr}
\begin{lrbox}{\mntr}
  \begin{lstlisting}[style=agree,numbers=left]
    const is_latched : bool = true;

    -- start user definitions
    assume "One automation request in flight at a time" : *\label{line:mon-assume}*
      true -> (req => pre(Historically(not req) or Since(not req, rsp)));

    const MAX_LATENCY : int = 1; *\label{line:mon-const}*

    eq rsp : bool = event(Response);
    eq req : bool = event(Request);

    eq isPending : bool = Since(not rsp, req and not rsp);*\label{line:mon-pending}*
    eq latency : int = 0 -> (if req then 0 else pre(latency) + 1);*\label{line:mon-latency}*

    eq policy : bool = (rsp => req) ->
                         (    (isPending => latency < MAX_LATENCY)
                          and (rsp => (req or pre(isPending))));
    *\label{line:mon-policy}*
    -- stop user definitions

    eq alert : bool = (not policy) -> *\label{line:mon-alert}*
                        ((is_latched and pre(alert)) or not policy);

    guarantee "Alert port tracks alert variable" :
      event(Alert) = alert;
    guarantee "Output if not alerted" :
      if (not(alert) and rsp) then
          event(Output) and (Output = Response)
      else
          not (event(Output));
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
      \scalebox{0.62}{\usebox{\flt}} \\
    \end{tabular}
  \end{center}
  \caption{Code contract specification for high-assurance filter.}
  \label{fig:filter}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
    \scalebox{0.62}{\usebox{\mntr}} \\
    \end{tabular}
  \end{center}
  \caption{Code contract specification for high-assurance monitor.}
  \label{fig:monitor}
\end{figure}


As previously discussed, transformations carried out in the BriefCASE
interface have created a cyber-hardened system, protecting against
malicious AI behavior, by inserting a high-assurance filter and
monitor between the AI and the WM (see \figref{fig:hardened}). The
filter protects the WM from malformed data and the monitor protects
the WM from (possibly malicious) spontaneous or delayed responses.
These components were added, one at a time, by
\begin{enumerate}
  \item selecting the connection in the model where the
    component is to appear,
  \item choosing the appropriate transformation, and
  \item specifying the relevant filtering or monitoring \emph{policy} (behavior).
\end{enumerate}

%% The system designer provides configuration parameters for the
%% transformation in a dialogue box.  The dialogue box for adding a
%% filter is shown in \figref{fig:dialogue}.  All high-assurance
%% components rely on a \emph{policy} to define behavior as seen in the
%% last field of the dialogue box.  A filter policy defines well-formed
%% data while a monitor policy defines an invariant over inputs and
%% outputs.  These policies can be stated directly in the wizard, or they
%% can be left blank and added later to the AGREE contract generated by
%% the transformation.

BriefCASE creates all the needed AADL for the new high-assurance
component, and its connections in the system implementation, as part
of the transformation.  It also creates a default AGREE specification
that defines everything about the component behavior, leaving only the
component behavior (policy) to be specified.


Code contracts for the filter and monitor are shown in
\figref{fig:filter} and \figref{fig:monitor}.\footnote{KLS: do we discuss wellformedness anywhere?} In general, the
\konst{eq}-statements of a code contract keep track of
state and provide data values from which to compute values to place on
the outputs.

\subsubsection{Monitor specification}
BriefCASE generates everything but the
\konst{eq}-statements in \linesref{line:mon-assume}{line:mon-policy} of
\figref{fig:monitor}.  As with the filter, the guarantees
completely define the output, as required for synthesis, in terms of
the policy and the alert.  The
\texttt{alert} variable defined on \lineref{line:mon-alert} depends
not just on the policy but also on configuration details supplied when
the component is specified.  At configuration
time, \texttt{is\_latched} has been set to \konst{true}, thus making
the alert persistent, meaning that once the alert is raised, it is
always raised; otherwise, it is the complement of the policy value in
the current step.

The monitor policy is defined by marking when a request is not
satisfied, \texttt{isPending} on \lineref{line:mon-pending}, and
counting the number of steps between requests, \texttt{latency} on
\lineref{line:mon-latency}.  The \texttt{isPending} variable is true
whenever there is a request that does not coincide with a
response--\emph{not response since request and not response}.  The
\texttt{latency} variable starts at zero, resets on every request, and
otherwise increments by one.

The latency bound for the monitor is defined by the constant
\texttt{MAX\_LATENCY} on \lineref{line:mon-const}.  Here the constant
is set to one to be consistent with the system specification from the
previous section.  At time 0 the policy is trivial: a response
requires an accompanying request.  After time 0, if a request is
pending in the current time step, then the latency must still be under
the bound, and if there is a response, then it closes a request now or
a pending request from earlier in time.

The policy definition only works if there is never more than one
outstanding request at a time; otherwise, the latency counter resets
incorrectly.  That requirement is encoded in the assumption on
\lineref{line:mon-assume} and is the same assumption used for the
system input.  The policy can be written without needing the
assumption, but it is much simpler to write with the assumption.

As shown in \figref{fig:hardened-certificate}, the cyber-hardened
system passes AGREE verification.  That means that the high-assurance
components protect the WM from the untrusted AI generating malformed
data, spontaneous responses, or delayed responses.  Synthesis must
generate precise implementations of the high-assurance component
specifications for the AGREE verification result to apply to the
deployed system.  Precise in this context means that the
implementations match the input to output relations defined in the
specifications.
