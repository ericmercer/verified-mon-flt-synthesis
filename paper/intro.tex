In recent years, aerospace stakeholders have become aware that avionics systems are subject to possible cyber-attacks just like other cyber-physical systems.  In addition to being fault-tolerant, safety-critical avionics systems must also be {\em cyber-resilient}. Cyber-resiliency means that the system is tolerant to cyberattacks just as safety-critical systems are tolerant to random faults: they recover and continue to execute their mission function, or safely shut down, as requirements dictate. 

Unfortunately, systems engineers are currently given few development tools to help answer even basic questions about potential vulnerabilities and mitigations, and instead rely on process-oriented checklists and guidelines.  Cyber vulnerabilities are often discovered during penetration testing late in the development process.  Worse yet, they may be discovered after the product has been fielded, necessitating extremely expensive and time-consuming remediation. This is not a sustainable development model.

The DARPA Cyber Assured Systems Engineering (CASE) program is targeted to developing design, analysis, and verification tools that enable systems engineers to {\em design-in} cyber-resiliency for complex cyber-physical systems.\footnote{The
  views expressed are those of the authors and do not reflect the
  official policy or position of the Defense Advanced
  Research Projects Agency (DARPA) or the U.S. Government.}
The result is a Model-Based Systems Engineering (MBSE) environment called {\em BriefCASE} which is based on the Architecture Analysis and Design Language (AADL)~\cite{aadl}.  BriefCASE extends the Open Source AADL Tool Environment (OSATE) to add new design, analysis, and code generation capabilities targeted at building cyber-resilient systems.  

BriefCASE provides access to two analysis tools (GearCASE~\cite{gearcase2020} and DCRYPPS~\cite{dcrypps2019}) that can examine AADL models to detect potential cyber vulnerabilities and suggest requirements for mitigation.  
A library of architectural transforms guides systems engineers through automated model transformations that modify the architecture to address these requirements, possibly inserting new high-assurance components into the system. 
Implementations for these new high-assurance components are synthesized from formal specifications using the Semantic Properties for Language and Automata Theory (SPLAT) tool~\cite{slind-hcss2020},~\cite{formal-filter-synth-langsec}.
Formal verification that the transformed system model satisfies its cyber requirements is accomplished via model checking using the Assume Guarantee Reasoning Environment (AGREE)~\cite{agree2013}.  Cyber-resilient code implementing the verified model is automatically generated using the High Assurance Modeling and Rapid Engineering for Embedded Systems (HAMR) toolkit~\cite{hamr}.  If desired, this code can be targeted to the formally verified seL4 secure microkernel~\cite{sel4-2009}.

A novel aspect of the approach is the ability to automatically transformation the model to insert high-assurance components to harden the system against potential cyber-vulnerabilities. The behavior of the model is given by contracts on components expressed in the AGREE modeling language. These contracts are modified as a result of the cyber-vulnerability analysis to assume properties on the input and and guarantee properties of the output that reflect a hardened system. In the absence of any transformation to implement the hardening, AGREE fails to prove the system cyber-hardened.

The two automatic transforms discussed in this paper are the insertion of filters to prevent malformed data from malicious actors from being propagated to downstream components, and monitors to detect and alert unexpected behaviors arising from untrusted components. These transformations not only change the architecture of the model by adding in new components, but they generate a complete formal specification for the behavior of the inserted high-assurance components in the AGREE language. Those specifications are sufficient for model checking to prove that with the high-assurance components, hardened system meets its cyber-resiliency requirements.

The other novel aspect of the approach is the synthesis of the AGREE specifications for the high-assurance components to CakeML. This paper agues that synthesis to CakeML to be correct. CakeML then provides a verified compilation path to several different target binaries proving that the meaning of the CakeML is exactly preserved in the final binaries. Assuming the deployed cyber-hardened system is scheduled as intended by the AADL model, and the HAMR generated communication fabric delivers messages between components as expected, then the AGREE model checking results hold for the deployed system in that in detects and prevents the indicated cyber-vulnerabilities over all possible finite inputs. Future work is lifting this result to infinite input traces as these systems are inherently reactive and intended to run forever.

The approach is motivated, and illustrated, in a simple example. A full case study applying these transformations to a UAV system that uses the Air Force Research Laboratory's OpenUxAS services for route planning is briefly reported. Here the transforms add filters to guard against malformed input and monitors to guard against ground station spoofing and malicious flight plans from OpenUxAS. The case study system is significantly more complex than the example and shows the viability of the modeling approach to full-scale industrial design.

\begin{comment}
Here is the basic process:
\begin{enumerate}
  \item CakeML provides a mechanism to take a defined logic in HOL4 and turn it into CakeML in a way that exactly preserves the meaning of the logic.
  \item Verified components are created by defining the meaning of the components in HOL4, and then using the existing theories to turn that meaning into CakeML
  \item Contiguity types provide a formalism for defining a language and recognizing membership in a language via a matcher
  \item Contiguity types include dependent types and the ability to define when a type is malformed
  \item Define a contract language that makes assumptions on input and guarantees properties on output
  \item Give meaning to the contract language in terms of traces (not easy to do because of the state)
  \item Show how the contract can be expressed in terms of a step function 
  \item The step-function is lifted to traces
  \item A contract defines a language over traces
  \item A step function recognizes membership in that language (prefix closed)
  \item Follow the same pattern used in contiguity types
  \item The CakeML comes for free once the HOL4 theories are shown
\end{enumerate}


Set the context for this work: define system level theorem that we intend to prove with the added components? Big picture of the overall goal of the project.

Components (complexity (and expressiveness) increases along the way):
* Filter: takes a stream of data and delivers a new stream of data where the property is enforced--reasons over an infinite stream of date. Connects to the system correctness over traces. Predicate on a single piece of data, paying no attention to previous history--no temporal awareness, deciting if it passes or not. Can be very secure and very efficient.
* Monitor: Captures a relation over time on the data. Is able to reason about temporal properties. Supports multiple inputs and is able to do arbitrary computation for complex output over the inputs.

The attestation gate is an aside to show how the tools we have are rich enough to create other complex things that blend the two: filter and monitor.

This paper addresses only the verified components. Here is what we verify:

* The resulting assembly code exactly implements the specification--preserves the meaning of the original specification in the actual assembly code.

Scheduling and Trace Relationships: we assume a stream of correct data-types and the existence of some scheduler to schedule components appropriately. In the later section we give an example of a system that uses seL4 with a pacer to schedule over different domains to provide memory isolation. Scheduling atd the relation to the trace semantics is not part of this paper.


Revised outline:

Describe the system level context with the AGREE analysis that proves system level properties of streams. A system is a collection of components and connections. We assume a finite set of defined datatypes for the connections. A well-formed system is acyclic and provides some suitable set of input streams to consume.

Every component is defined by its inputs, outputs, and a contract. The contract language is simplified AGREE: requires, guarantees, eq, and expressions that include \emph{pre}. Requires are pre-conditions assumed on the input. Guarantees are post-conditions the output must meet. A component consumes a stream of input and produces and stream of output. A well-formed component is also acyclic. 

For a component to by synthesized, its contract must be strong enough to define the meaning of every output (e.g., the value assumed by the output and under what conditions it assumes that value). 

The AGREE analysis reasons about the system with its component composition proving that all contracts are respected. Failures are counter-examples where some input requirement is violated. The analysis provides a system level guarantee. 

Component synthesis compiles the contract to imperative code that implements the contract. The claim is that the final compiled code preserves the meaning of the contract: it produces the same output stream for any input stream that conforms to its pre-condition. The synthesis is accomplished with the CakeML framework that provides the additional guarantee that the post-condition holds over an infinite stream (e.g., that it the component does not terminate and always satisfies the post-condition if the pre-condition holds---Hoare logic extended to statement that diverge).

The semantics is synchronous data-flow. Computation takes zero time as does transport. The system must be well-formed. 

Motivate with some example: watchdog example on DNS monitoring for DOS attacks? Estimates the growth rate of the input request queue over time and sends a throttle signal if the growth is too fast (looks suspicious)---any bounded response of behavior based watch-dog is fine.
\end{comment}