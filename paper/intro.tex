Here is the basic process:
\begin{enumerate}
  \item CakeML provides a mechanism to take a defined logic in HOL4 and turn it into CakeML in a way that exactly preserves the meaning of the logic.
  \item Verified components are created by defining the meaning of the components in HOL4, and then using the existing theories to turn that meaning into CakeML
  \item Contiguity types provide a formalism for defining a language and recognizing membership in a language via a matcher
  \item Contiguity types include dependent types and the ability to define when a type is malformed
  \item Define a contract language that makes assumptions on input and guarantees properties on output
  \item Give meaning to the contract language in terms of traces (not easy to do because of the state)
  \item Show how the contract can be expressed in terms of a step function 
  \item The step-function is lifted to traces
  \item A contract defines a language over traces
  \item A step function recognizes membership in that language (prefix closed)
  \item Follow the same pattern used in contiguity types
  \item The CakeML comes for free once the HOL4 theories are shown
\end{enumerate}


Set the context for this work: define system level theorem that we intend to prove with the added components? Big picture of the overall goal of the project.

Components (complexity (and expressiveness) increases along the way):
* Filter: takes a stream of data and delivers a new stream of data where the property is enforced--reasons over an infinite stream of date. Connects to the system correctness over traces. Predicate on a single piece of data, paying no attention to previous history--no temporal awareness, deciting if it passes or not. Can be very secure and very efficient.
* Monitor: Captures a relation over time on the data. Is able to reason about temporal properties. Supports multiple inputs and is able to do arbitrary computation for complex output over the inputs.

The attestation gate is an aside to show how the tools we have are rich enough to create other complex things that blend the two: filter and monitor.

This paper addresses only the verified components. Here is what we verify:

* The resulting assembly code exactly implements the specification--preserves the meaning of the original specification in the actual assembly code.

Scheduling and Trace Relationships: we assume a stream of correct data-types and the existence of some scheduler to schedule components appropriately. In the later section we give an example of a system that uses seL4 with a pacer to schedule over different domains to provide memory isolation. Scheduling atd the relation to the trace semantics is not part of this paper.


Revised outline:

Describe the system level context with the AGREE analysis that proves system level properties of streams. A system is a collection of components and connections. We assume a finite set of defined datatypes for the connections. A well-formed system is acyclic and provides some suitable set of input streams to consume.

Every component is defined by its inputs, outputs, and a contract. The contract language is simplified AGREE: requires, guarantees, eq, and expressions that include \emph{pre}. Requires are pre-conditions assumed on the input. Guarantees are post-conditions the output must meet. A component consumes a stream of input and produces and stream of output. A well-formed component is also acyclic. 

For a component to by synthesized, its contract must be strong enough to define the meaning of every output (e.g., the value assumed by the output and under what conditions it assumes that value). 

The AGREE analysis reasons about the system with its component composition proving that all contracts are respected. Failures are counter-examples where some input requirement is violated. The analysis provides a system level guarantee. 

Component synthesis compiles the contract to imperative code that implements the contract. The claim is that the final compiled code preserves the meaning of the contract: it produces the same output stream for any input stream that conforms to its pre-condition. The synthesis is accomplished with the CakeML framework that provides the additional guarantee that the post-condition holds over an infinite stream (e.g., that it the component does not terminate and always satisfies the post-condition if the pre-condition holds---Hoare logic extended to statement that diverge).

The semantics is synchronous data-flow. Computation takes zero time as does transport. The system must be well-formed. 

Motivate with some example: watchdog example on DNS monitoring for DOS attacks? Estimates the growth rate of the input request queue over time and sends a throttle signal if the growth is too fast (looks suspicious)---any bounded response of behavior based watch-dog is fine.