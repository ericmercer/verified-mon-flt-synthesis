This section formalizes AGREE's assume-guarantee reasoning by defining the set of verification conditions that AGREE must check.
The verification conditions succinctly summarize what in means when AGREE proves that a system implementation satisfies it specification.
These conditions are useful in understanding how the semantics in synthesis differ from those in the assume-guarantee reasoning in \secref{sec:semantics}.

This section then introduces the AGREE contract specification language through the cyber-hardened system of \figref{fig:hardened}.
It details the specification of that top-level system interface.
It then discusses the specifications for the filter and the monitor.
These two specifications are those that are synthesized to equivalent CakeML by SPLAT.

\subsection{Verification Conditions}
\input{verification-conditions}

\subsection{Contract Language Specification}
\newsavebox{\sw}
\begin{lrbox}{\sw}
\begin{lstlisting}[style=agree,numbers=left,escapeinside={*}{*}]
eq req : bool = event(AutomationRequest);*\label{line:sw-event-def-start}*
eq avl : bool = event(AirVehicleLocation);
eq wp : bool = event(Waypoint);
eq strt: bool = event(Start);
eq alrt : bool = event(Alert);*\label{line:sw-event-def-end}*

assume "Automation requests are well-formed" : *\label{line:sw-assume-1}*
  req => WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
assume "Air vehicle locations are well-formed" : *\label{line:sw-assume-2}*
  avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);    
assume "One automation request in flight at a time" : *\label{line:sw-assume-3}*
  true -> 
  (req => pre(Historically(not req) or Since(not req, strt)));
      
guarantee "Waypoints coincide with air vehicle locations":
  wp => avl;
guarantee "Starts include a new waypoint" :
  strt => wp;
guarantee "Waypoints are well-formed" : 
  wp => WELL_FORMED_WAYPOINT(Waypoint);
guarantee "Starts within one cycle of requests if not alerting" :
  (strt => ((not alrt) and req)) -> 
  (strt => ((not alrt) and (req or pre(req))));
guarantee "Alert if not started within one cycle of requests" :
    true -> ((pre(req and not strt) and not strt) => alrt);
guarantee "Once alerted always alerted" :
  not alrt or (Once(alrt) and alrt);
\end{lstlisting}
\end{lrbox}

\begin{figure}
  \begin{center}
    \scalebox{0.62}{\usebox{\sw}}
  \end{center}
  \caption{The SW component contract.}
  \label{fig:sw}
\end{figure}

The AGREE specification language uses stream concepts, and operators, from the Lustre language \cite{10.1145/41625.41641}.
As with Lustre, the semantics are synchronous dataflow where the inputs, outputs, and expressions are data streams that comply with the input assumptions.
Contracts are evaluated in dependency order with inputs being propagated to outputs through all contracts until they stabilize; as such, the contracts, and thereby the top-level model, must be acyclic.\footnote{An apparent syntactic cycle, where a component is linked back to itself, may be broken temporally by inserting delay elements.}
Once the contracts have stabilized, the model takes a synchronous step to the next input data in the stream.
The semantics do not model computation or communication delay.
The output of one contract is seen at the input of any downstream contract in the same step of the input data stream.
The language is best introduced through example.

The AGREE specification for the SW component in the example of Section~\ref{sec:example} is given in \figref{fig:sw}.
The specification uses \texttt{eq} statements to define variables local to the contract specification.
For example, \lineref{line:sw-event-def-start} defines the \texttt{req} variable to be equivalent to the \texttt{event(AutomationRequest)} expression.

All the named ports in the corresponding AADL component are in the scope of the specification, and there are additional implicit boolean \emph{event} inputs (or outputs) associated with event ports.
An \texttt{event} expression refers to that implicit input (or output) boolean value and is true when data is placed on the named port and false otherwise.
\linesref{line:sw-event-def-start}{line:sw-event-def-end} create local variables that are true when data is present on the corresponding event ports for the component.
The local variables here are purely for convenience in writing the specification.

Assumptions are best understood as being evaluated on the pre-state of a component while guarantees are evaluated on the post-state.
Contract languages such as Eifle and Dafny make this pre-state assume evaluation and post-state guarantee evaluation part of the semantics, and it relies on operators such as \texttt{old} it indicate when a guarantee should use a pre-state value in evaluating a guarantee.
AGREE differs from these languages in that it evaluates both the assumptions and guarantees in the post-state of the component.
But like other languages it relies on the operator \texttt{pre} to refer to a pre-state evaluation in both the assumptions and guarantees.
Since streams are associated with all expressions in AGREE meaning that they are defined through time, the \texttt{pre} operator simply returns the previous value of the enclosed expression (e.g., it looks back one step in time).


The \texttt{assume} statement is a string description followed by a predicate.
Those on \lineref{line:sw-assume-1} and \lineref{line:sw-assume-2} are implications requiring that when data is present it is well-formed.
The well-formed predicates themselves are defined elsewhere using AGREE functions.
The assumption on \lineref{line:sw-assume-3} uses the \emph{followed-by} operator, \texttt{->}, and the \texttt{pre} operator to constrain when requests can arrive at the input.


The followed-by expression defines what happens at the first instance in the stream, time 0, and then what follows after. 
Here the assumption is \texttt{true} at time 0, and then takes on the truth value of the implication in all future instances.
The implication uses the \texttt{pre} expression in its left operand. 
In the example, it is guarded by the followed-by since expressions are undefined before time 0.
So in the first instance at time 0, the assumption is \texttt{true}, and then at every instance after, it depends on when the request arrives.

The stream semantics in AGREE mean that it is possible to use PLTL operators that look back in time.

REPLACE ALL: 
The \emph{Alert if start is not bounded relative to a request} guarantee is an invariant on the expression \texttt{policy or since}, meaning that either the policy holds or the alert is sounding.
The \texttt{policy} is defined by two local values: \texttt{current} and \texttt{previous}.
The \texttt{current} value is asserted when in the current time step there is a request with a response, or there is no request and no response.

The value of \texttt{previous} in the current time step relies on values from the previous time step.
The \texttt{->} operator designates initialization, as the previous time step is undefined in the first step of the system.
The left operand to the operator is the initial value of \texttt{previous} at start, which in this example is \texttt{(req and not rsp)}, because seeing a request with no response is inconclusive in the first step of the system.
The right operand is the value of \texttt{previous} after the initial step.
Here the \texttt{pre} operator refers to the value of the expression \texttt{(req and not rsp)} in the prior time step, \texttt{previous} is true if the previous time step made a request without a matching response and the current time step has the matching response to that request with no new request.

The value of \texttt{since} in \emph{Alert if start is not bounded relative to a request} relies on its own value in the previous time step.
The intuitive reading of the expression is that the alert has been true since the time when it first sounded.
The first \texttt{alrt} sets \texttt{since} to true, and once the value of \texttt{since} is true, that value persists as long as \texttt{alrt} holds.
The \emph{Alert if start is not bounded relative to a request} guarantee defines one requirement of a cyber-hardened system implementation.
Together with the other guarantees, the contract models the expected input and output of the system as a whole.

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
      \includegraphics[scale=0.3]{dialogue.png}
    \end{tabular}
  \end{center}
  \caption{Wizard for automatically transforming the model with a filter.}
  \label{fig:dialogue}
\end{figure}

\newsavebox{\flt}
\begin{lrbox}{\flt}
\begin{lstlisting}[style=agree,numbers=left]
eq policy : bool = 
  WELL_FORMED_AUTOMATION_RESPONSE(Input);

guarantee Filter_Output
  "Filter output is well-formed" :
  if event(Input) and policy then 
    event(Output) and Output = Input
  else not event(Output);
\end{lstlisting}
\end{lrbox}

\newsavebox{\mntr}
\begin{lrbox}{\mntr}
\begin{lstlisting}[style=agree,numbers=left]
const is_latched : bool = true;
const MAX_LATENCY : int = 1;
    
eq rsp : bool = event(Response);
eq req : bool = event(Request);

eq isPending : bool = Since(not rsp, req and not rsp);
eq latency : int = 0 -> (if req then 0 else pre(latency) + 1);

eq policy : bool = (rsp => req) ->
                   (    (isPending => latency < MAX_LATENCY)   
                    and (rsp => (req or pre(isPending))));
eq alert : bool = (not policy) -> 
                  ((is_latched and pre(alert)) or not policy);

assume "One outstanding request at a time" :
  (true -> (req => not pre(isPending))); 
                          
guarantee "Alert port tracks alert variable" :
  event(Alert) = alert;
guarantee "Output if not alerted" :
  if (not(alert) and rsp) then
    event(Output) and (Output = Response)
  else
    not (event(Output));    
\end{lstlisting}
\end{lrbox}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
      \scalebox{0.62}{\usebox{\flt}} \\
    \end{tabular}
  \end{center}
  \caption{Contract specification for high-assurance filter.}
  \label{fig:filter}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{tabular}{c}
      \scalebox{0.62}{\usebox{\mntr}} \\
    \end{tabular}
  \end{center}
  \caption{Contract specification for high-assurance monitor.}
  \label{fig:monitor}
\end{figure}

As noted previously, the original system fails to guarantee the cyber requirements.
BriefCASE provides two transformations to address the failing requirements: inserting a filter and inserting a monitor.
The component is added by selecting the connection in the model where the high-assurance component is to be added, and then choosing the appropriate transformation.
The system designer can provide transform configuration parameters in a wizard, as shown in \figref{fig:dialogue}.
The policy of the high-assurance component can be stated directly in the wizard, or it can be left blank.
In this example, the policy is specified as \texttt{WELL\_FORMED\_AUTOMATION\_RESPONSE(Input)}.
Additionally, because a transformation is ultimately driven by a cyber requirement, BriefCASE updates an embedded Resolute assurance case~\cite{resolute-destion}.
REMOVE: Resolute keeps track of the evidential artifacts necessary for supporting the requirement, and can be run at any time to determine whether those artifacts are valid.

The AGREE contract specification generated by the transform is shown in \figref{fig:filter}.
The guarantee is stylized for synthesis and completely defines the meaning of the output under every possible input.
The resulting AGREE specification for the monitor in this example is shown in \figref{fig:monitor}.
The \texttt{is\_latched} value makes the alert persistent, meaning that once the alert is raised, it is always raised.
This behavior is one of the several options available in the dialogue.
The definition for \texttt{policy} is taken by the system developer from the contract in \figref{fig:sw}.
As before, the guarantees for the outputs are autogenerated by the tool and completely define each output under every possible input.
