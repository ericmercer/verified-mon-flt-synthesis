\begin{figure}
  \[
    \begin{array}{rcl}
      \mathit{c}    & = & \konst{input}\ [(f : \tau)\ldots] \\
                    &   & \konst{output}\ [(f : \tau)\ldots] \\
                    &   & \konst{eq}\; [(f : \tau := \mathit{exp})\ldots] \\
                    &   & \konst{guarantee}\ [\mathit{bexp}\ldots]\\\\
      
      \lval         & = & f \mid \lval \, [ \mathit{exp} ]
                          \mid \lval . f \\ \\

      f             & = & \mathit{varName} \\ \\

      \mathit{exp}  & = & \konst{Loc}\; \lval
                          \mid \konst{nLit}\; \konst{nat}
                          \mid \mathit{constname} \\
                    & | & \mathit{exp} + \mathit{exp}
                          \mid \mathit{exp} * \mathit{exp} \\
                    & | & (\mathit{exp}\ \rightarrow\ \mathit{exp}) \\
                    & | & (\konst{pre}\ \mathit{exp}) \\
                    & | & (\konst{ite}\ \mathit{bexp}\ \mathit{exp}\ \mathit{exp})\\
                    & | & \mathit{bexp} \\ \\
                          
      \mathit{bexp} & = & \konst{bLoc}\; \lval
                          \mid  \konst{bLit}\; \konst{bool}
                          \mid  \neg \mathit{bexp}
                          \mid  \mathit{bexp} \land \mathit{bexp} \\
                    & | & \mathit{exp} = \mathit{exp} 
                    \mid  \mathit{exp} < \mathit{exp}
\end{array}
\]
\caption{Syntax for high-assurance component specifications.}
\label{fig:syntax}
\end{figure}

The specification language for a high-assurance component is in \figref{fig:syntax}. A specification defines the inputs, outputs, local values, and guarantees for each output. A type $\tau$ is a contiguity type, and $(f : \tau)\ldots$ means zero or more repetition (e.g., Kleene star). An $\lval$ must eventually resolve to something that can be assigned. The expression language divides out Boolean expressions to simplify the semantics but is otherwise typical. The \konst{Loc} and \konst{bLoc} refer to the value of an $\lval$, while \konst{nLit} and \konst{bLit} indicate a literal. The language includes the initialization ($\rightarrow$), \konst{pre}, and if-then-else (\konst{ite}) operators.

The semantics are only defined for \emph{well-formed} specifications. A specification is well-formed if and only if
\begin{compactenum}
\item Every $\lval$ is unique;
\item the \konst{eq} list is in dependency order and the expressions are acyclic;
\item the associated $\lval$ with each \konst{Loc} and \konst{bLoc} expression is a valid reference in the environment;
\item the associated literal with each \konst{nLit} and \konst{bLit} has the correct type;
\item \konst{pre} expressions do not refer past the beginning of the associated streams;
\item the expression list from \konst{guarantee} exactly corresponds in size and order to the list from \konst{output}; and
\item every expression in the list from \konst{guarantee} defines its corresponding output value under all input combinations.
\end{compactenum}
These checks are part of the synthesis but omitted to simplify the presentation.

An environment, $\theta: \lval \mapsto \konst{string}$ binds L-values to strings. $\Delta : \konst{string} \to \mathbb{N}$ binds constant names to numbers. Functions $\konst{toN}:\konst{string}\to\mathbb{N}$ and $\konst{toB}:\konst{string}\to\konst{bool}$ interpret byte sequences to numbers and booleans, respectively. 

The well-formed assumption enables the use of a single global environment for the semantics. The semantics are synchronous data-flow on a single clock defined over a sequences of environments where $\theta^i$ is the $i^\mathrm{th}$ environment in the stream. Expression evaluation is defined in the context of this environment stream as shown is \figref{fig:eval}. Here, $\konst{eval}\; i\; e$ carries with it the index of the environment to be used for the expression.

\begin{figure*}
\[
\begin{array}{l}
\konst{eval}\; i\; e =
\mathtt{case}\; e\
 \left\{
 \begin{array}{lcl}
    \konst{Loc}\; \lval & \Rightarrow & \konst{toN}(\theta^i(\lval)) \\
    \konst{nLit}\; n & \Rightarrow & n  \\
    \mathit{constname} & \Rightarrow & \Delta(\mathit{constname})  \\
    e_1 + e_2 & \Rightarrow & \konst{eval}\; i \; e_1 + \konst{eval}\; i \; e_2  \\
    e_1 * e_2 & \Rightarrow & \konst{eval}\; i \; e_1 * \konst{eval}\; i \; e_2  \\
    e_1 \rightarrow e_2 & \Rightarrow &  \mathbf{if}\; i = 0\; \mathbf{then}\; \konst{eval}\; i \; e_1\; 
                                         \mathbf{else}\; \konst{eval}\; i \; e_2 \\
    (\konst{pre}\; e) & \Rightarrow &  \konst{eval}\; i-1 \; e
  \end{array}
 \right.
 \\ \\
\konst{evalB}\; i \; b =
\mathtt{case}\; b\
 \left\{
 \begin{array}{lcl}
    \konst{bLoc}\; \lval & \Rightarrow & \konst{toB}(\theta^i(\lval)) \\
    \konst{bLit}\; b & \Rightarrow & b \\
    \neg b & \Rightarrow & \neg(\konst{evalB} \; b)  \\
    b_1 \lor b_2 & \Rightarrow & \konst{evalB}\; i \;b_1 \lor \konst{evalB}\; i \;b_2   \\
    b_1 \land b_2 & \Rightarrow & \konst{evalB}\; i \;b_1 \land \konst{evalB}\; i \;b_2   \\
    e_1 = e_2 & \Rightarrow & \konst{eval} \;e_1 = \konst{eval}\; i \;e_2   \\
    e_1 < e_2 & \Rightarrow & \konst{eval} \;e_1 < \konst{eval}\; i \;e_2
  \end{array}
 \right.
\end{array}
\]
\caption{Expression evaluation in the context of a stream on environments.}
\label{fig:eval}
\end{figure*}


Each environment in the stream is initially partial meaning that it only contains mappings for the inputs. \emph{Stepping} the specification updates the current environment and checks the invariance of the guarantees. In other words, at the $i^\mathrm{th}$ step, $\theta^i$ is updated with the result of the sequential evaluation of the \konst{eq}-statements in the specification and then the guarantees are checked for invariance. 

The meaning of the specification is a set of finite environment streams where the guarantees hold at each step of the streams and the updated mappings or the \konst{eq}-statements are consistent with the statements.


At the $i^\mathrm{th}$ step of the stream, $\theta^i$


Each \emph{step} of the specification updates a corresponding environment in the stream making it complete at the end of the step.  

The environments in the stream are partial containing only mappings for inputs.

\begin{comment}
  A \emph{system} is a collection of \emph{components}, \emph{connections} between components, a \emph{scheduler} to order execution, and a \emph{system environment} for primary inputs. The computation for the component in this work is defined entirely by a step function:
\[
\konst{stepFn} : \mathit{inports} \times \mathit{stateVars} \to \mathit{stateVars}
\]
The scheduler \emph{activates} components in some order. Activating a component is defined as follows: 
\[
\begin{array}{ll}
 \mathit{inportVals} & = \konst{readInputs}(); \\
 (v_1,\ldots,v_k) & = \konst{readState}() ; \\
 ({v_1}',\ldots,{v_k}') & = \konst{stepFn} (\mathit{inportVals},\mathit{stateVars}) ; \\
 \multicolumn{2}{l}{\konst{writeState}({v_1}',\ldots,{v_k}');} \\
 \multicolumn{2}{l}{\konst{writeOutputs}({v_1}',\ldots,{v_k}');} \\
\end{array}
\]
It is assumed that the scheduler follows some sensible partial order of component activation and allows each component sufficient time for its computation.
\end{comment}