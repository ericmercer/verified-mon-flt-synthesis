\begin{figure}
  \[
    \begin{array}{rcl}
      \mathit{c}    & = & \konst{input}\ [(f : \tau)\ldots] \\
                    &   & \konst{output}\ [(f : \tau)\ldots] \\
                    &   & [\mathit{stmts}\ldots] \\
                    &   & \konst{assume}\ [\mathit{bexp}\ldots] \\
                    &   & \konst{guarantee}\ [\mathit{bexp}\ldots] \\ \\
      
      \mathit{stmts}& = & \konst{subcomp}\ \lval\dots\ c \\
                    & | & \konst{eq}\; f : \tau := \mathit{exp} \\ \\
                    
      \lval & = & f \mid \lval \, [ \mathit{exp} ]
                          \mid \lval . f \\ \\

      f             & = & \mathit{varName} \\ \\

      \mathit{exp}  & = & \konst{Loc}\; \lval
                          \mid \konst{nLit}\; \konst{nat}
                          \mid \mathit{constname} \\
                    & | & \mathit{exp} + \mathit{exp}
                          \mid \mathit{exp} * \mathit{exp} \\
                    & | & (\mathit{exp}\ \rightarrow\ \mathit{exp}) \\
                    & | & (\konst{pre}\ \mathit{exp}) \\
                    & | & (\konst{ite}\ \mathit{bexp}\ \mathit{exp}\ \mathit{exp})\\
                    & | & \mathit{bexp} \\ \\
                          
      \mathit{bexp} & = & \konst{bLoc}\; \lval
                          \mid  \konst{bLit}\; \konst{bool}
                          \mid  \neg \mathit{bexp}
                          \mid  \mathit{bexp} \land \mathit{bexp} \\
                    & | & \mathit{exp} = \mathit{exp} 
                    \mid  \mathit{exp} < \mathit{exp}
\end{array}
\]
\caption{Syntax for component specifications.}
\label{fig:syntax}
\end{figure}

A \emph{system} in this model of computation is a \emph{component} that is defined by a specification (see \figref{fig:syntax}). A specification defines inputs, outputs, statements, assumptions for pre-conditions, and guarantees for post-conditions. A statement can be a subcomponent definition with its input binding or a local variable definition.

A type $\tau$ is a contiguity type which is a self-describing dependent type specification (add citation). An $\lval$ is a reference to an \emph{L-value} from compiler concepts and is an expression that can appear on the left hand side of an assignment. Alpha renaming is assumed so that every $\lval$ is unique.

An environment, $\theta: \lval \mapsto \konst{string}$ binds L-values to strings. $\Delta : \konst{string} \to \mathbb{N}$ binds constant names to numbers. Functions $\konst{toN}:\konst{string}\to\mathbb{N}$ and $\konst{toB}:\konst{string}\to\konst{bool}$ interpret byte sequences to numbers and booleans, respectively. 

The semantics are synchronous data-flow on a single clock defined over a sequence of environments where $\theta^i$ is the $i^\mathrm{th}$ environment in the stream. Expression evaluation is defined in the context of the environment stream in \figref{fig:eval}.

\begin{figure*}
\[
\begin{array}{l}
\konst{eval}\; i\; e =
\mathtt{case}\; e\
 \left\{
 \begin{array}{lcl}
    \konst{Loc}\; \lval & \Rightarrow & \konst{toN}(\theta^i(\lval)) \\
    \konst{nLit}\; n & \Rightarrow & n  \\
    \mathit{constname} & \Rightarrow & \Delta(\mathit{constname})  \\
    e_1 + e_2 & \Rightarrow & \konst{eval}\; i \; e_1 + \konst{eval}\; i \; e_2  \\
    e_1 * e_2 & \Rightarrow & \konst{eval}\; i \; e_1 * \konst{eval}\; i \; e_2  \\
    e_1 \rightarrow e_2 & \Rightarrow &  \mathbf{if}\; i = 0\; \mathbf{then}\; \konst{eval}\; i \; e_1\; 
                                         \mathbf{else}\; \konst{eval}\; i \; e_2 \\
    (\konst{pre}\; e) & \Rightarrow &  \konst{eval}\; i-1 \; e
  \end{array}
 \right.
 \\ \\
\konst{evalB}\; i \; b =
\mathtt{case}\; b\
 \left\{
 \begin{array}{lcl}
    \konst{bLoc}\; \lval & \Rightarrow & \konst{toB}(\theta^i(\lval)) \\
    \konst{bLit}\; b & \Rightarrow & b \\
    \neg b & \Rightarrow & \neg(\konst{evalB} \; b)  \\
    b_1 \lor b_2 & \Rightarrow & \konst{evalB}\; i \;b_1 \lor \konst{evalB}\; i \;b_2   \\
    b_1 \land b_2 & \Rightarrow & \konst{evalB}\; i \;b_1 \land \konst{evalB}\; i \;b_2   \\
    e_1 = e_2 & \Rightarrow & \konst{eval} \;e_1 = \konst{eval}\; i \;e_2   \\
    e_1 < e_2 & \Rightarrow & \konst{eval} \;e_1 < \konst{eval}\; i \;e_2
  \end{array}
 \right.
\end{array}
\]
\caption{Expression evaluation in the context of a stream on environments.}
\label{fig:eval}
\end{figure*}

The initial environment stream only contains mappings for primary inputs along the entire stream. Stepping the component updates the current environment. In other words, at the $i^\mathrm{th}$ step, $\theta^i$ is updated with the result of each component evaluation. A component step traverses the component sequentially to update the environment recursing into subcomponents after binding inputs. Assume the component is written in dependency order. 

\begin{comment}
  A \emph{system} is a collection of \emph{components}, \emph{connections} between components, a \emph{scheduler} to order execution, and a \emph{system environment} for primary inputs. The computation for the component in this work is defined entirely by a step function:
\[
\konst{stepFn} : \mathit{inports} \times \mathit{stateVars} \to \mathit{stateVars}
\]
The scheduler \emph{activates} components in some order. Activating a component is defined as follows: 
\[
\begin{array}{ll}
 \mathit{inportVals} & = \konst{readInputs}(); \\
 (v_1,\ldots,v_k) & = \konst{readState}() ; \\
 ({v_1}',\ldots,{v_k}') & = \konst{stepFn} (\mathit{inportVals},\mathit{stateVars}) ; \\
 \multicolumn{2}{l}{\konst{writeState}({v_1}',\ldots,{v_k}');} \\
 \multicolumn{2}{l}{\konst{writeOutputs}({v_1}',\ldots,{v_k}');} \\
\end{array}
\]
It is assumed that the scheduler follows some sensible partial order of component activation and allows each component sufficient time for its computation.
\end{comment}