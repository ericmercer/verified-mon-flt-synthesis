The formal specification of a component, and the synthesis of that specification, relies on \emph{contiguity types} (cite contiguity). A contiguity type is a self-describing specification for messages. Its formalism has basis in formal languages. Similar to how a regular expression implies a set of words that form its language, so does a contiguity type specification imply a set of messages for its language where a message is a finite sequence of contiguous bytes (e.g., a string). 

What makes contiguity type specification more expressive than regular expressions is that it is self-describing meaning that the contents of the message itself may determine the rest of the message. An example is the \texttt{AutomationResponse} from the system in the previous section with its contiguity type specification.
{\small
\begin{verbatim}
  {TaskID : i64
   Length : u8
   Waypoints : Waypoint[Length]
  }
\end{verbatim}
}
\noindent The \texttt{Waypoints} array size depends on the value of \texttt{Length} so the actual number of bytes in the message depends on the contents of the message itself. 

The type specifications may also carry meta-information about the contents of the message.
{\small
\begin{verbatim}
  {Latitude : float
   lt-rng : Assert (-90 <= Latitude <= 90) 
   Longitude : float
   lng-rng : Assert (-180 <= Longitute <= 180)
   Altitude : float
   a-rng : Assert (10000 <= Altitude <= 15000)
  }
\end{verbatim}
}
\noindent Here the specification encodes the allowed ranges for each field of the waypoint. These can be checked while constructing a message from a sequence of bytes.

Every contiguity type specification has a corresponding \emph{matcher} that when given a message string returns true or false if that message belongs to the language of the specification. If the message does belong to the language, an \emph{environment} is provided to access each part of the message. An environment, $\theta: \lval \mapsto \konst{string}$ binds \emph{L-values} to strings. An L-value is an expression that can appear on the left hand side of an assignment. The syntax for $\lval$ is given in the next section.

The matcher itself is synthesized from the specification to CakeML. The synthesis includes a corresponding proof that the matcher recognizes the language of the specification, and the resulting environment, $\theta$, from a matched message produces the same message as the one matched when serialized. 

The inputs and outputs for a high-assurance component are defined by contiguity type specifications. The synthesis from the component specification relies on the corresponding matchers from the contiguity type specifications. Details of which are in the next section.
