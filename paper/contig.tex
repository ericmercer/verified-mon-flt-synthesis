The formal specification of a component, and the synthesis of that specification, relies on \emph{contiguity types}~\cite{contiguity-types} to define the input and output data (cite contiguity). A contiguity type is a self-describing specification for messages. Its formalism has basis in formal languages. Similar to how a regular expression implies a set of words that form its language, so does a contiguity type specification imply a set of messages for its language where a message is a finite sequence of contiguous bytes (e.g., a string). 

What makes contiguity type specification more expressive than regular expressions is that it is self-describing meaning that the contents of the message itself may determine the rest of the message. An example is the \texttt{AutomationResponse} from the system in the previous section with its contiguity type specification.
{\small
\begin{verbatim}
  {TaskID : i64
   Length : u8
   Waypoints : Waypoint[Length]
  }
\end{verbatim}
}
\noindent The \texttt{Waypoints} array size depends on the value of \texttt{Length} so the actual number of bytes in the message depends on the contents of the message itself. 

The type specifications may also carry meta-information about the contents of the message.
{\small
\begin{verbatim}
  {Latitude : float
   lt-rng : Assert (-90 <= Latitude <= 90) 
   Longitude : float
   lng-rng : Assert (-180 <= Longitute <= 180)
   Altitude : float
   a-rng : Assert (10000 <= Altitude <= 15000)
  }
\end{verbatim}
}
\noindent Here the specification encodes the allowed ranges for each field of the waypoint. These assumptions restrict the resulting language to include only conforming messages and can be checked while constructing a message from a sequence of bytes. The notation $\LangTheta{\tau}$ denotes the language defined by the specification $\tau$ using the environment $\theta$ for expression evaluation.

Every contiguity type specification has a corresponding CakeML \emph{matcher} that when given a message string returns true or false if that message belongs to the language of the specification. If the message does belong to the language, an \emph{environment} is provided to access each part of the message. An environment, $\theta: \lval \mapsto \konst{string}$ binds \emph{L-values} to strings, where an L-value is an expression that can appear on the left hand side of an assignment (e.g., \texttt{AutomationRequest.Waypoints[0].Latitude}). 

The main result of contiguity types is the proof of the relationship between the language of the specification and the synthesized matcher from the specification that is summarized below.
\[
  \konst{match}\; s_1s_2 = \konst{SOME}(\theta, s_2)
  \imp \theta(\tau) \cdot s_2 = s_1s_2 \wedge s_1 \in \LangTheta{\tau}
\]
If there is a match on the substring $s_1$, then reconstituting the string from the resulting environment and concatenating it with $s_2$ yields the original string, and the matched string $s_1$ is in the language of the type specification. 