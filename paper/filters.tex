\newcommand{\konst}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\imp}{\Rightarrow}
\newcommand{\lval}{\ensuremath{\mathit{lval}}}
\newcommand{\set}[1]{\ensuremath{\{ {#1} \}}}
\newcommand{\kstar}[1]{\ensuremath{{#1}^{*}}}
\newcommand{\Lang}[1]{\ensuremath{{\mathcal L}({#1})}}
\newcommand{\LangTheta}[1]{\ensuremath{{\mathcal L}_{\theta}({#1})}}
\newcommand{\itelse}[3]{\mbox{$\mathtt{if}\ {#1}\ \mathtt{then}\ {#2}\ \mathtt{else}\ {#3}$}}

% Latex trickery for infix div operator, from stackexchange

\makeatletter
\newcommand*{\bdiv}{%
  \nonscript\mskip-\medmuskip\mkern5mu%
  \mathbin{\operator@font div}\penalty900\mkern5mu%
  \nonscript\mskip-\medmuskip
}
\makeatother

A \emph{string} is an array of bytes. A \emph{language} is a set of strings. A \emph{recognizer} for a language determines if a string belongs to the language.  A language \emph{filter} uses a recognizer to pass an input string unchanged to the output if the string belongs to the given language; otherwise, it outputs an empty string. 

Languages in this work are formally defined by \emph{contiguity types}. A contiguity type specifies data as a laid out side-by-side array of elements in a string. Every contiguity type has an associated recognizer that precisely recognizes strings in the language. Filter synthesis translates the contiguity type recognizer into CakeML in a way that preserves the precision of the recognizer to guarantees that the CakeML recognizer recognizes the same language as the contiguity type recognizer from which it is derived. This statement is the main result of the paper for filters.

\subsection{Contiguity Types}

See \cite{contiguity} for a complete discussion. Contiguity types assume that a string is the \emph{result} of a
map from structured data. Figure \ref{contig-types} is the syntax. Contiguity types start with common base types (booleans,
characters, signed and unsigned integers, \etc) and are closed under
the construction of records, arrays, and unions. \footnote{We use
the terms ``\emph{contiguity type}, \konst{contig}, and $\tau$
interchangeably.}

\begin{figure}
\[
\begin{array}{rcl}
 \mathit{base} & = & \konst{bool} \mid \konst{char} \mid \konst{u8} \mid \konst{u16} \mid \konst{u32} \\
               & \mid & \konst{u64}  \mid \konst{i16} \mid \konst{i32} \mid \konst{i64} \mid \konst{float} \mid \konst{double} \\ \\

 \tau & = & \mathit{base} \\
      & \mid & \konst{Recd}\; (f_1 : \tau_1) \ldots (f_n : \tau_n) \\
      & \mid & \konst{Array}\; \tau \; \mathit{exp} \\
      & \mid & \konst{Alt}\; \mathit{bexp}\; \tau_1 \; \tau_2 \\ \\

\mathit{lval} & = & \mathit{varname} \mid
                    \mathit{lval} \, [ \mathit{exp} ] \mid
                    \mathit{lval} . \mathit{fieldname} \\ \\

\mathit{exp} & = & \konst{Loc}\; \mathit{lval}
              \mid \konst{nLit}\; \konst{nat}
              \mid \mathit{constname} \\
             & \mid & \mathit{exp} + \mathit{exp}
                   \mid \mathit{exp} * \mathit{exp} \\ \\

\mathit{bexp} & = & \konst{bLoc}\; \mathit{lval}
              \mid  \konst{bLit}\; \konst{bool}
              \mid  \neg \mathit{bexp}
              \mid  \mathit{bexp} \land \mathit{bexp} \\
              & \mid & \mathit{exp} = \mathit{exp} 
              \mid  \mathit{exp} < \mathit{exp}
\end{array}
\]
\caption{Syntax for contiguity types.}
\label{contig-types}
\end{figure}

Arithmetic and Boolean expressions define dependent types. The expressions rely on the notion of an \emph{L-value} to reference values in previous fields.

Theorem statement: the traces accepted by the specification match the traces accepted by the implementation. If we have have uninterpreted functions, then it may not be precise as the agree analysis as something may be rejected by agree but accepted by the implementation. Need to think about that carefully.

\subsection{Matcher Synthesis}