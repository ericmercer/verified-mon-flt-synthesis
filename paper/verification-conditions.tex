
\newcommand{\globally}{\konst{Always}}
\newcommand{\historically}{\konst{Hist}}
\newcommand{\assumes}{\ensuremath{A}}
\newcommand{\guarantees}{\ensuremath{P}}
\newcommand{\inputs}{\ensuremath{I}}
\newcommand{\outputs}{\ensuremath{O}}
\newcommand{\components}{\ensuremath{C}}
\newcommand{\component}{\ensuremath{c}}

The AGREE specification language, and semantics, are inspired by the Lustre language \cite{10.1145/41625.41641}.
Lustre reasons over a synchronous dataflow model where the inputs and outputs of
components are streams.
Informally, streams assign values to expressions at each point in time.
AGREE contracts express relationships between input and output streams by assuming a set of allowed input streams and then guaranteeing a corresponding set of allowed output streams.
Output for streams not included in the assumed input is undefined. 

When considering a system of components,
data flows through the components in dependency order, with inputs
being propagated to outputs through all contracts until they stabilize
(i.e., they cannot propagate further). Therefore, the subcomponent contracts, and
thus the top-level model, must be acyclic. 
Cyclic systems are made acyclic by breaking cycles with delays.
That is to say that input at the cut point reasons about previous input data rather than the current input data.
Once the data propagation
has stabilized, the model proceeds to the next input data in the input
streams. It is worth noting that the semantics do not model computation or communication
delay. The output of one contract is seen at the input of any
downstream contract in the same step of the input data stream.

From the system and component contracts, AGREE generates a set of
verification conditions to show that a system's component
implementation is correct~\cite{agree2013}.  The AGREE model checker
is then invoked to prove or disprove the verification
conditions. The contracts and verification conditions are expressed in
\emph{past-time linear temporal logic} (PLTL) \cite{10.1093/jigpal/8.1.55}.

PLTL is a logic enhanced with temporal operators able to
reason about the truth values of formulas through time.
It combines past-time operators that reason over the history of computation up to a point (PTLTL) and future-time operators that reason over the computation that follows that point (LTL).
Its semantics
are defined relative to a point in time $i$ and a finite trace of
system states $\pi = s_0, s_1, \ldots, s_i$.

The two PLTL operators necessary for the AGREE generated verification
conditions are $\globally$ that looks forward in time along
the trace and $\historically$ (historically) that looks backward in
time along the trace.  These are defined as
\begin{eqnarray*}
 (\pi, i) \models \globally(f) & \iff & \forall j \ge i, (\pi, j) \models f \\
(\pi, i) \models \historically(f) & \iff & \forall 0 \le j \le i, (\pi, j) \models f
\end{eqnarray*}
The $\models$-operator is read as \emph{satisfies}.  A trace at a
moment in time satisfies $\globally(f)$ if and only if it satisfies
$f$ in the current and all future states of $\pi$.  $\globally(f)$ is
invariant from the current moment into the future and $\historically$ is
invariant from the beginning of the trace to the current moment.

A \emph{system} is a tuple $(\inputs, \outputs, \assumes,
\guarantees,C)$, where $\inputs$ is the input set, $\outputs$ is the
output set, $\assumes$ is the set of assumptions, $\guarantees$ is the
set of guarantees, and $C$ are subcomponents.  A subcomponent
$\component$ is, hierarchically, also a system, and may be designated
by its own tuple $(\inputs_\component, \outputs_\component,
\assumes_\component, \guarantees_\component, C_c)$.  From the
components and their connections, $\mathbb{I}_\component$ is defined
to be the set of components providing input to some component
$\component$ in the system, and $\mathbb{O}$ is defined to be the set
of components that provide the output for the system.  

A system $S$ is
\emph{correct} if and only if for all components $c \in C$ the
following two verification conditions hold:
\begin{equation}\label{eq:assumes}
            \globally(\historically(\assumes \wedge
            \bigwedge_{\component^\prime \in \mathbb{I}_\component} P_{\component^\prime})
            \implies \assumes_\component)
\end{equation}
\begin{equation}\label{eq:guarantees}
            \globally(\historically(\assumes \wedge
            \bigwedge_{\component^\prime \in \mathbb{O}} \guarantees_{\component^\prime})
            \implies \guarantees)
\end{equation}
The conditions from \eqref{eq:assumes} verify the input assumptions on each component under
the system assumptions and upstream component guarantees.  They check
if the component guarantees and system assumptions are strong enough
to imply input assumptions on all immediate downstream components.
The condition in \eqref{eq:guarantees} checks the output guarantees of the system under the
system assumptions and component guarantees that provide the output.
It checks if the guarantees on components providing primary outputs
are strong enough to imply the system guarantees.

If all the verification conditions hold (AGREE uses $k$-inductive
model checking to automatically prove or disprove each generated
verification condition), then the system is said to be \emph{correct},
meaning that the system composition meets input assumptions at each
input as well as the guarantees on the system output. A consequence of
this result is that $\globally(\historically(\assumes) \implies
\guarantees)$ holds for the system contract.
In this way the Liskhov substitution principle applies meaning that the implementation is a safe substitution for the system contract \cite{10.1145/62139.62141}.

The expanded property lists in \figref{fig:example-certificate} and
\figref{fig:hardened-certificate} are the results from verifying or
disproving the above verification conditions.  The additional
unexpanded results at the bottom of the figures prove
\emph{self-consistency} in the contracts.  It is not uncommon to
accidentally write contracts that are self-contradicting.  For
example, a contract may guarantee an output be two different values in
the same moment of time.  AGREE generates additional verification
conditions that prove each component contract, and the composition of
contracts, self-consistent.
