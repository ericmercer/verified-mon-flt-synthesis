\begin{comment}
This section gives an abstract mathematical overview of AGREE's
compositional reasoning system, defining assume-guarantee contracts
and the verification conditions that AGREE checks in order to
modularly establish overall system correctness at the model level.
The syntax and semantics of AGREE are sketched in some detail.  The
discussion then becomes more concrete, showing---by example---how the
AGREE contract language is used to specify the cyber-hardened system
of \figref{fig:hardened}. The discussion proceeds from the
system-level contract to the filter and monitor components, which rely
on the notion of a \emph{code contract} to support code generation.
\end{comment}

We now give an overview of a formal model for AGREE syntax and
semantics.  The discussion then becomes more concrete, showing by
example, how the AGREE language is used to specify the properties of
the SW system introduced in \secref{sec:example}.  Any implementation
of the SW system must guarantee the specification output under the
system assumptions.

The syntax of AGREE is essentially that of quantifier-free first order
predicate logic supplemented with a few temporal operators. The terms
(\emph{e}) are arithmetic expressions built from variables ($v$) and
numeric and boolean literals ($c$), while formulas (\emph{b}) are
built using logical connectives from atomic formulas (\emph{a}) based
on the familiar comparison operators.
\[
\begin{array}{rcl}
e & ::= & v \mid c \mid e \;\set{+,*,/}\; e \\
a & ::= & e\; \set{=,<}\; e \\
b & ::= & v \mid c \mid a \mid \neg b
            \mid b \; \set{\land,\lor,\imp,\iff}\; b
\end{array}
\]
AGREE includes a conditional, $\itelse{b}{(-)}{(-)}$, for both terms
and formulas. To support port handling, AGREE defines a predicate
$\konst{event}(p)$, which tests if an event (or event-data) port $p$ is
signaled. Lastly, AGREE supports temporal operators \emph{previously}
$\konst{pre}(-)$, \emph{followed-by} $(-) \to (-)$, and historically
$\konst{Hist}(-)$.

\subsection{Semantics}
The semantics of terms and formulas, as mentioned in the previous
section, is in terms of \emph{streams of values}. Values encompass at
least booleans and numbers, but can be readily extended to include
records and arrays. A value stream is a total function from time
(natural numbers including 0) to values:
\[
 \konst{stream} = \mathbb{N}_0 \to \konst{value}
\]
Given an \emph{environment} $E : \konst{name} \mapsto \konst{stream}$
binding variable names to value streams, the semantics $\sem{-}^E_t$
of terms and formulas defines the meaning of compound syntax in terms
of the meaning of subexpressions. The value of a variable $v$ at time
$t$ is found by looking up the stream bound to $v$ in $E$ (call it
$s$) and returning $s_t$. Some clauses of the semantics follow,
omitting the temporal operators:
\[
\begin{array}{rcl}
\sem{v}^E_t & = & E(v)(t) \\
\sem{c}^E_t & = & c \\
\sem{e_1 + e_2}^E_t & = & \sem{e_1}^E_t + \sem{e_2}^E_t \\
   & \cdots & \\
\sem{b_1 \land b_2}^E_t & = & \sem{b_1}^E_t \land \sem{b_2}^E_t \\
   & \cdots & \\
\end{array}
\]

The temporal operators deal with time in more significant ways. The
value of $\konst{pre}(e)$ at time $t$ is the value of $e$ at time
$t-1$ (at time zero, \konst{pre} is undefined).  A followed-by, $e_1
\to e_2$, evaluates to $e_1$ at time zero; otherwise it is $e_2$.
Followed-by is typically used to give a value to a stream in the first
step so that subsequent steps are able to use $\konst{pre}(e)$.
\[
\begin{array}{rcl}
\sem{\konst{pre}(e)}^E_t & = & \sem{e}^E_{t-1}, \mathrm{when}\ t > 0 \\
\sem{e_1 \to e_2}^E_t & = & \itelse{t=0}{\sem{e_1}^E_0}{\sem{e_2}^E_t} \\
\sem{\konst{Hist}(b)}^E_t & = & \forall n \leq t.\; \sem{b}^E_n
\end{array}
\]

Although basic, these definitions can be used to define higher-level
past-time operators from PLTL such as \konst{Once} and \konst{Since}.
These can be expressed in a recursive style as follows:
%% \[
%%    \begin{array}{rcl}
%%       \sem{\konst{Once}(b)}^E_t & = & \sem{b \vee (\konst{false} \to \konst{pre}(o))}^E_t \\
%%       \sem{\konst{Since}(a, b)}^E_t & = & \sem{b \vee (a and (\konst{false} \to \konst{pre}(o)))}^E_t \\
%%    \end{array}
%% \]
\[
\begin{array}{rcl}
\konst{Once}(b) & = & b \to b \vee \konst{pre}(\konst{Once}(b)) \\
\konst{Since}(a, b) & = & b \to b \lor (a \land \konst{pre}(\konst{Since}(a, b))
\end{array}
\]
\noindent $\konst{Once}(b)$ is true if $b$ has ever been true before, or in, the
current moment.  $\konst{Since}(a, b)$ is true if $a$ has been true in
all moments up to the present one since $b$ most recently became true.
All other past-time operators of PLTL can be defined similarly \cite{monitor}.

\paragraph{AGREE notation.}
AGREE uses ASCII notation for the mathematical syntax we have
defined. The following table spells out the mapping.
\[
\begin{tabular}{l|l|l}
 Operation & Math. notation & AGREE \\ \hline
 followed-by &  $e \to e$          & \verb+e -> e+  \\
 logical implication &  $e \imp e$ & \verb+e => e+ \\
 if-and-only-if &  $e \iff e$      & \verb+e <=> e+ \\
 logical and &  $e \land e$      & \verb+e and e+ \\
 logical or &  $e \lor e$      & \verb+e or e+ \\
 logical not & $\neg b$      & \verb+not b+ \\
 variable definition & $v = e$     & \verb+eq v e+ \\
 Previously  & $\konst{pre}(b)$ & \verb+pre(b)+ \\
 Historically  & $\konst{Hist}(b)$ & \verb+Historically(b)+ \\
\end{tabular}
\]
