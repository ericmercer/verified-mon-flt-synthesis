package SW
public

with Base_Types;
renames Base_Types::all;
with HAMR;
with CASE_Properties;
with CASE_Scheduling;
with AGREE_PLTL;
renames AGREE_PLTL::all;

  --------------
  -- Waypoint --
  --------------
  data Waypoint
  end Waypoint;

  data implementation Waypoint.Impl
    subcomponents
      Latitude: data Float_64;
      Longitude: data Float_64;
      Altitude: data Float_32;
  end Waypoint.Impl;

  ------------------------
  -- Automation Request --
  ------------------------
  data AutomationRequest
  end AutomationRequest;

  data implementation AutomationRequest.Impl
      subcomponents
        TaskID: data Integer_64;
      properties
        HAMR::Bit_Codec_Max_Size => 128 bits;
  end AutomationRequest.Impl;
  
  ------------------------
  -- AutomationResponse --
  ------------------------
  data AutomationResponse
  end AutomationResponse;

  data implementation AutomationResponse.Impl
    subcomponents
      TaskID: data Integer_64;
      Length: data Unsigned_8;
      Waypoints: data Waypoint.Impl[3];
    properties
      HAMR::Bit_Codec_Max_Size => 1664 bits;
  end AutomationResponse.Impl;

  ------------------------------
  -- Bounded Response Monitor --
  ------------------------------
  thread CASE_Monitor_Thr
    features
      Response: in event data port AutomationResponse.Impl;
      Request: in event data port AutomationRequest.Impl;
      Alert: out event port;
      Output: out event data port AutomationResponse.Impl;
    properties
      CASE_Properties::Monitoring => 100;
      CASE_Properties::Component_Spec => ("Alert", "Output");
      CASE_Properties::Monitor_Latched => true;
    annex agree {**
      const is_latched : bool = true;
      const MAX_LATENCY : int = 1;
      
      eq rsp : bool = event(Response);
      eq req : bool = event(Request);
      
      eq isPending : bool = Since(not rsp, req and not rsp);
      eq latency : int = 0 -> (if req then 0 else pre(latency) + 1);
      
      eq policy : bool = (rsp => req) ->
                         (    (isPending => latency < MAX_LATENCY)   
                          and (rsp => (req or pre(isPending))));
      eq alert : bool = (not policy) -> 
                        ((is_latched and pre(alert)) or not policy);
      
      assume "One outstanding request at a time" :
      	(true -> (req => not pre(isPending))); 
      	                        
      guarantee "Alert port tracks alert variable" :
        event(Alert) = alert;
      guarantee "Output if not alerted" :
        if (not(alert) and rsp) then
          event(Output) and (Output = Response)
        else
          not (event(Output));    
    **};
  end CASE_Monitor_Thr;

  thread implementation CASE_Monitor_Thr.Impl
    properties            
      Dispatch_Protocol => Periodic;
      Period => 500ms;
      Compute_Execution_Time => 2ms .. 2ms;
      Stack_Size => 65536 bytes;
      Source_text => ("src/CASE_Monitor.c");
  end CASE_Monitor_Thr.Impl;

  process CASE_Monitor
    features
      Response: in event data port AutomationResponse.Impl;
      Request: in event data port AutomationRequest.Impl;
      Alert: out event port;
      Output: out event data port AutomationResponse.Impl;
    properties
      CASE_Properties::Monitor_Latched => true;
  end CASE_Monitor;

  process implementation CASE_Monitor.Impl
    subcomponents
      CASE_Monitor: thread CASE_Monitor_Thr.Impl;
    connections
      c01: port Response -> CASE_Monitor.Response;
      c02: port Request -> CASE_Monitor.Request;
      c03: port CASE_Monitor.Alert -> Alert;
      c04: port CASE_Monitor.Output -> Output;
    properties
      CASE_Scheduling::Domain => 4;
    annex agree {**
      lift contract;
    **};
  end CASE_Monitor.Impl;
  
  ----------------------------------------
  -- Automation Response message Filter --
  ----------------------------------------
  thread CASE_Filter_Thr
    features
      Input: in event data port AutomationResponse.Impl;
      Output: out event data port AutomationResponse.Impl;
    properties
      CASE_Properties::Filtering => 100;
      CASE_Properties::Component_Spec => ("Output");
    annex agree {**
      eq policy : bool = 
        WELL_FORMED_AUTOMATION_RESPONSE(Input);
     
      guarantee Filter_Output
        "Filter output is well-formed" :
        if event(Input) and policy then 
          event(Output) and Output = Input
        else not event(Output);
    **};
  end CASE_Filter_Thr;

  thread implementation CASE_Filter_Thr.Impl
    properties
      Dispatch_Protocol => Periodic;
      Period => 500ms;
      Compute_Execution_Time => 2ms .. 2ms;
      Stack_Size => 65536 bytes;
      Source_text => ("src/CASE_Filter_Thr.c");
  end CASE_Filter_Thr.Impl;

  process CASE_Filter
    features
      Input: in event data port AutomationResponse.Impl;
      Output: out event data port AutomationResponse.Impl;
  end CASE_Filter;

  process implementation CASE_Filter.Impl
    subcomponents
      CASE_Filter: thread CASE_Filter_Thr.Impl;
    connections
      c1: port Input -> CASE_Filter.Input;
      c2: port CASE_Filter.Output -> Output;
    properties
      CASE_Scheduling::Domain => 3;
    annex agree {**
      lift contract;
    **};
  end CASE_Filter.Impl;

  ----------
  -- AI --
  ----------
  thread AI_Thr
    features
      AutomationRequest: in event data port AutomationRequest.Impl;
      AirVehicleLocation: in event data port Waypoint.Impl;
      AutomationResponse: out event data port AutomationResponse.Impl;
    annex agree {**
      eq req : bool = event(AutomationRequest);
      eq avl : bool = event(AirVehicleLocation);
      eq rsp : bool = event(AutomationResponse);
          
      assume "Automation requests are well-formed" :
          req => WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
      assume "Air vehicle locations are well-formed" : 
          avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);
    **};
  end AI_Thr;

  thread implementation AI_Thr.Impl
    properties
      Dispatch_Protocol => Periodic;
      Period => 500ms;
      Compute_Execution_Time => 2ms .. 2ms;
      Stack_Size => 65536 Bytes;
      Source_text => ("third-party");
  end AI_Thr.Impl;

  process AI
    features
      AutomationRequest : in event data port AutomationRequest.Impl;
      AirVehicleLocation : in event data port Waypoint.Impl;
      AutomationResponse : out event data port AutomationResponse.Impl;
  end AI;

  process implementation AI.Impl
    subcomponents
      AI: thread AI_Thr.Impl;
    connections
      c01: port AutomationRequest -> AI.AutomationRequest;
      c02: port AirVehicleLocation -> AI.AirVehicleLocation;
      c03: port AI.AutomationResponse -> AutomationResponse;
    properties
      CASE_Scheduling::Domain => 2;
    annex agree {**
      lift contract;
    **};
  end AI.Impl;
    
  ----------------------
  -- Waypoint Manager --
  ----------------------
  thread WaypointManager_Thr
    features
      AutomationResponse: in event data port AutomationResponse.Impl;
      AirVehicleLocation: in event data port Waypoint.Impl;
      Start: out event port;
      Waypoint: out event data port Waypoint.Impl;
    annex agree {**     
      eq rsp : bool = event(AutomationResponse);
      eq wp : bool = event(Waypoint);
      eq strt: bool = event(Start);
      eq avl : bool = event(AirVehicleLocation);
      
      assume "Automation responses are well-formed" :
        rsp => WELL_FORMED_AUTOMATION_RESPONSE(AutomationResponse);
      assume "Air vehicle locations are well-formed" :
        avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);
                  
      guarantee "Waypoints coincide with air vehicle locations":
        wp => avl;
      guarantee "Starts mark new automation responses" :
        strt <=> rsp;
      guarantee "Starts include a new waypoint" :
        strt => wp;
      guarantee "Waypoints are well-formed" : 
        wp => WELL_FORMED_WAYPOINT(Waypoint);
      **};
  end WaypointManager_Thr;

  thread implementation WaypointManager_Thr.Impl
    properties
      Dispatch_Protocol => Periodic;
      Period => 500ms;
      Compute_Execution_Time => 2ms .. 2ms;
      Stack_Size => 65536 bytes;
      Source_text => ("src/wpm.c");
  end WaypointManager_Thr.Impl;

  process WaypointManager
    features
      AutomationResponse: in event data port AutomationResponse.Impl;
      AirVehicleLocation: in event data port Waypoint.Impl;
      Start: out event port;
      Waypoint: out event data port Waypoint.Impl;
  end WaypointManager;

  process implementation WaypointManager.Impl
    subcomponents
      WaypointManager: thread WaypointManager_Thr.Impl;
    connections
      c01: port AutomationResponse -> WaypointManager.AutomationResponse;
      c02: port AirVehicleLocation -> WaypointManager.AirVehicleLocation;
      c03: port WaypointManager.Start -> Start;
      c04: port WaypointManager.Waypoint -> Waypoint;
    properties
      CASE_Scheduling::Domain => 5;       
    annex agree {**
      lift contract;
    **};
  end WaypointManager.Impl;
  
  ---------------
  -- No Output --
  ---------------
  thread noOutput
  	features
  	  Output: out event port;
  	annex agree {**
  	  guarantee "Never output" :
        not event(Output);
  	**};
  end noOutput;
  
  thread implementation noOutput.Impl
  	properties
      Dispatch_Protocol => Periodic;
      Period => 500ms;
      Compute_Execution_Time => 2ms .. 2ms;
      Stack_Size => 65536 bytes;
      Source_text => ("src/noOutput.c");
  end noOutput.Impl;
  
  -------------
  -- Process --
  -------------
  process SW
    features
      AutomationRequest: in event data port AutomationRequest.Impl;
      AirVehicleLocation: in event data port Waypoint.Impl;
      Waypoint: out event data port Waypoint.Impl;
      Start: out event port;
      Alert: out event port;
    annex agree {**            
      eq req : bool = event(AutomationRequest);
      eq avl : bool = event(AirVehicleLocation);
      eq wp : bool = event(Waypoint);
      eq strt: bool = event(Start);
      eq alrt : bool = event(Alert);
      
      assume "Automation requests are well-formed" :
        req => WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
      assume "Air vehicle locations are well-formed" :
        avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);    
      assume "One automation request in flight at a time" :
      	true -> (req => pre(Historically(not req) or Since(not req, strt)));
           
      guarantee "Waypoints coincide with air vehicle locations":
        wp => avl;
      guarantee "Starts include a new waypoint" :
        strt => wp;
      guarantee "Waypoints are well-formed" : 
        wp => WELL_FORMED_WAYPOINT(Waypoint);
      guarantee "Starts occur within one cycle of requests if not alerting" :
        (strt => ((not alrt) and req)) -> 
        (strt => ((not alrt) and (req or pre(req))));
      guarantee "Alert if not started within one cycle of requests" :
       	true -> ((pre(req and not strt) and not strt) => alrt);
      guarantee "Once alerted always alerted" :
        not alrt or (Once(alrt) and alrt);
    **};
  end SW;
    
  ----------------------------
  -- Process Implementation --
  ----------------------------
  process implementation SW.Impl
    subcomponents
      AI: thread AI_Thr.Impl;
      WM: thread WaypointManager_Thr.Impl;
      ALRT : thread noOutput.Impl;
    connections

      --------------------
      -- Primary Inputs --
      --------------------
      c01: port AutomationRequest -> AI.AutomationRequest;
      c03: port AirVehicleLocation -> AI.AirVehicleLocation;
      c04: port AirVehicleLocation -> WM.AirVehicleLocation;

      ----------
      --  AI  --
      ----------
      c05: port AI.AutomationResponse -> WM.AutomationResponse;

      ---------
      -- WM --
      ---------
      c06: port WM.Waypoint -> Waypoint;
      c07: port WM.Start -> Start;

      ----------
	    -- ALRT --
	    ----------
	    c08: port ALRT.Output -> Alert;
    annex resolute {**
      check HAMR_Guidelines
    **};
  end SW.Impl;
    
  ------------------------------------------
  -- Cyber-assured Process Implementation --
  ------------------------------------------
  process implementation SW.cyber_Impl
    subcomponents
      AI: thread AI_Thr.Impl;
      WM: thread WaypointManager_thr.Impl;
      Filter: thread CASE_Filter_Thr.Impl;
      Monitor: thread CASE_Monitor_Thr.Impl;
    connections

      --------------------
      -- Primary Inputs --
      --------------------
      c01: port AutomationRequest -> AI.AutomationRequest;
      c03: port AirVehicleLocation -> AI.AirVehicleLocation;
      c04: port AirVehicleLocation -> WM.AirVehicleLocation;

      ----------
      --  AI  --
      ----------
      c05: port AI.AutomationResponse -> Filter.Input;

      ---------
      -- WM --
      ---------
      c06: port WM.Waypoint -> Waypoint;
      c07: port WM.Start -> Start;

      c2: port Filter.Output -> Monitor.Response;
      c3: port AutomationRequest -> Monitor.Request;
      c4: port Monitor.Output -> WM.AutomationResponse;
      c5: port Monitor.Alert -> Alert;
  end SW.cyber_Impl;
    
  ------------
  -- System --
  ------------    
  system SWSystem
    features
      AutomationRequest: in event data port AutomationRequest.Impl;
      AirVehicleLocation: in event data port Waypoint.Impl;
      Waypoint: out event data port Waypoint.Impl;
      Start: out event port;
      Alert: out event port;
    annex agree {**   
      eq req : bool = event(AutomationRequest);
      eq avl : bool = event(AirVehicleLocation);
      eq wp : bool = event(Waypoint);
      eq strt: bool = event(Start);
      eq alrt : bool = event(Alert);
      
      assume "Automation requests are well-formed" :
        req => WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
      assume "Air vehicle locations are well-formed" :
        avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);    
      assume "One automation request in flight at a time" :
      	true -> (req => pre(Historically(not req) or Since(not req, strt)));
           
      guarantee "Waypoints coincide with air vehicle locations":
        wp => avl;
      guarantee "Starts include a new waypoint" :
        strt => wp;
      guarantee "Waypoints are well-formed" : 
        wp => WELL_FORMED_WAYPOINT(Waypoint);
      guarantee "Starts occur within one cycle of requests if not alerting" :
        (strt => ((not alrt) and req)) -> 
        (strt => ((not alrt) and (req or pre(req))));
      guarantee "Alert if not started within one cycle of requests" :
       	true -> ((pre(req and not strt) and not strt) => alrt);
      guarantee "Once alerted always alerted" :
        not alrt or (Once(alrt) and alrt);
    **};
  end SWSystem;

  -----------------------------------------
  -- Cyber-assured System Implementation --
  -----------------------------------------

  ----------------------------------------------------------------------
  processor proc
  end proc;

  processor implementation Proc.Impl
    properties
      Frame_Period => 1000ms;
      Clock_Period => 2ms;
      CASE_Scheduling::Max_Domain => 6;
      CASE_Scheduling::Schedule_Source_Text => "src/domain_schedule.c";
  end Proc.Impl;
  ----------------------------------------------------------------------
    
  system implementation SWSystem.cyber_Impl
    subcomponents
      PROC: processor Proc.Impl;
      AI: process AI.Impl;
      WM: process WaypointManager.Impl;
      Filter: process CASE_Filter.Impl;
      Monitor: process CASE_Monitor.Impl;
    connections
      --------------------
      -- Primary Inputs --
      --------------------
      c01: port AutomationRequest -> AI.AutomationRequest;
      c02: port AutomationRequest -> Monitor.Request;
      c03: port AirVehicleLocation -> AI.AirVehicleLocation;
      c04: port AirVehicleLocation -> WM.AirVehicleLocation;

      ----------
      --  AI  --
      ----------
      c05: port AI.AutomationResponse -> Filter.Input;

      ---------
      -- WM --
      ---------
      c06: port WM.Waypoint -> Waypoint;
      c07: port WM.Start -> Start;

      ------------
      -- Filter --
      ------------
      c08: port Filter.Output -> Monitor.Response;
      
      -------------
      -- Monitor --
      -------------
      c09: port Monitor.Output -> WM.AutomationResponse;
      c10: port Monitor.Alert -> Alert;
    properties
      Actual_Processor_Binding => (reference (Proc)) applies to AI;
      Actual_Processor_Binding => (reference (Proc)) applies to WM;
      Actual_Processor_Binding => (reference (Proc)) applies to Filter;
      Actual_Processor_Binding => (reference (Proc)) applies to Monitor;
      
      HAMR::Default_Bit_Width => 32;
      HAMR::Default_Max_Sequence_Size => 1;
      HAMR::Max_String_Size => 256;
      HAMR::Bit_Codec_Raw_Connections => true;
      
    annex resolute {**
      check HAMR_Guidelines
    **};
  end SWSystem.cyber_Impl;
    
  process should_doNothing_when_noInput
    features
      Response: in event data port AutomationResponse.Impl;
      Request: in event data port AutomationRequest.Impl;
      Alert: out event port;
      Output: out event data port AutomationResponse.Impl;
    annex agree {**
      assume "No Response" :
      	event(Response) = false;
      assume "No Request" :
      	event(Request) = false;
      	
      guarantee "Not Alert" :
      	not event(Alert);
      guarantee "Not Output" :
      	not event(Output);
    **};
  end should_doNothing_when_noInput;
  
  process Implementation should_doNothing_when_noInput.test
  	subcomponents
  	  Monitor: thread CASE_Monitor_Thr.Impl;
  	connections
  	  c00: port Response -> Monitor.Response;
  	  c01: port Request -> Monitor.Request;
  	  c02: port Monitor.Alert -> Alert;
  	  c03: port Monitor.Output -> Output;
  end should_doNothing_when_noInput.test;
  
  process should_alertAndNotOutput_when_responseWithoutRequest
    features
      Response: in event data port AutomationResponse.Impl;
      Request: in event data port AutomationRequest.Impl;
      Alert: out event port;
      Output: out event data port AutomationResponse.Impl;
    annex agree {**
      assume "Response" :
      	event(Response) = true ->
      	event(Response) = false;
      assume "Not Request" :
      	event(Request) = false;
      	
      guarantee "Alert" :
      	event(Alert);
      guarantee "Not Output" :
      	not event(Output);
    **};
  end should_alertAndNotOutput_when_responseWithoutRequest;
  
  process Implementation should_alertAndNotOutput_when_responseWithoutRequest.test
  	subcomponents
  	  Monitor: thread CASE_Monitor_Thr.Impl;
  	connections
  	  c00: port Response -> Monitor.Response;
  	  c01: port Request -> Monitor.Request;
  	  c02: port Monitor.Alert -> Alert;
  	  c03: port Monitor.Output -> Output;
  end should_alertAndNotOutput_when_responseWithoutRequest.test;
  
  process should_notAlertAndOutput_when_responseAndRequest
    features
      Response: in event data port AutomationResponse.Impl;
      Request: in event data port AutomationRequest.Impl;
      Alert: out event port;
      Output: out event data port AutomationResponse.Impl;
    annex agree {**
      assume "One Response" :
      	event(Response) = true ->
      	event(Response) = false;
      assume "One Request" :
      	event(Request) = true ->
      	event(Request) = false;
      	
      guarantee "Not Alert" :
      	not event(Alert);
      guarantee "Output once" :
      	(event(Output) and Output = Response) ->
      	not event(Output);
    **};
  end should_notAlertAndOutput_when_responseAndRequest;
  
  process Implementation should_notAlertAndOutput_when_responseAndRequest.test
  	subcomponents
  	  Monitor: thread CASE_Monitor_Thr.Impl;
  	connections
  	  c00: port Response -> Monitor.Response;
  	  c01: port Request -> Monitor.Request;
  	  c02: port Monitor.Alert -> Alert;
  	  c03: port Monitor.Output -> Output;
  end should_notAlertAndOutput_when_responseAndRequest.test;
  
   process should_notAlertAndOutput_when_responseOneStepAfterRequest
    features
      Response: in event data port AutomationResponse.Impl;
      Request: in event data port AutomationRequest.Impl;
      Alert: out event port;
      Output: out event data port AutomationResponse.Impl;
    annex agree {**
      eq index : int = prev(index + 1, 0);
      
      assume "One Response one step after Request" :
      	    ((index = 0) => not event(Response))
      	and ((index = 1) => event(Response))
      	and ((index >= 2) => not event(Response));
      assume "One Request" :
      	(event(Request) = true) ->
      	(event(Request) = false);
      
      guarantee "Not Alert" :
      	not event(Alert);
      guarantee "Output one step after Request at same time as Response" :
      	    ((index = 0) => not event(Output))
      	and ((index = 1) => (event(Output) and Output = Response))
      	and ((index >= 2) => not event(Output));
    **};
  end should_notAlertAndOutput_when_responseOneStepAfterRequest;
  
  process Implementation should_notAlertAndOutput_when_responseOneStepAfterRequest.test
  	subcomponents
  	  Monitor: thread CASE_Monitor_Thr.Impl;
  	connections
  	  c00: port Response -> Monitor.Response;
  	  c01: port Request -> Monitor.Request;
  	  c02: port Monitor.Alert -> Alert;
  	  c03: port Monitor.Output -> Output;
  end should_notAlertAndOutput_when_responseOneStepAfterRequest.test;
  
  process should_alertAndNotOutput_when_noResponseOneStepAfterRequest
    features
      Response: in event data port AutomationResponse.Impl;
      Request: in event data port AutomationRequest.Impl;
      Alert: out event port;
      Output: out event data port AutomationResponse.Impl;
    annex agree {**
      assume "One response one step after Request" :
      	(event(Response) = false);
      assume "One Request" :
      	(event(Request) = true) ->
      	(event(Request) = false);
      
      guarantee "Alert one step after Request" :
      	not event(Alert) -> event(Alert);
      guarantee "No Output ever" :
      	not event(Output);
    **};
  end should_alertAndNotOutput_when_noResponseOneStepAfterRequest;
  
  process Implementation should_alertAndNotOutput_when_noResponseOneStepAfterRequest.test
  	subcomponents
  	  Monitor: thread CASE_Monitor_Thr.Impl;
  	connections
  	  c00: port Response -> Monitor.Response;
  	  c01: port Request -> Monitor.Request;
  	  c02: port Monitor.Alert -> Alert;
  	  c03: port Monitor.Output -> Output;
  end should_alertAndNotOutput_when_noResponseOneStepAfterRequest.test;
  
  ---------------------
  -- AGREE Functions --
  ---------------------
  annex agree {**	
    const TASK_ID : int = 42;
    fun WELL_FORMED_WAYPOINT(point : Waypoint.Impl) : bool =
                        (point.Latitude >= -90.0 and point.Latitude <= 90.0)
                    and (point.Longitude >= -180.0 and point.Longitude <= 180.0) 
                    and (point.Altitude >= 10000.0 and point.Altitude <= 15000.0);
    fun WELL_FORMED_TASK_ID(id : int) : bool =
                (id = TASK_ID);
    fun WELL_FORMED_AUTOMATION_REQUEST(msg : AutomationRequest.Impl) : bool =
                        WELL_FORMED_TASK_ID(msg.TaskID);
    fun WELL_FORMED_AUTOMATION_RESPONSE(msg : AutomationResponse.Impl) : bool =
                        (WELL_FORMED_TASK_ID(msg.TaskID))
                    and (forall waypoint in msg.Waypoints, WELL_FORMED_WAYPOINT(waypoint));
  **};
end SW;