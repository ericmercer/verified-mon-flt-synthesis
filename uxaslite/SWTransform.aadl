package SWTransform
public

	with Base_Types;
	renames Base_Types::all;

	with Data_Model;
	with HAMR;
	with CASE_Properties;

	thread CASE_Monitor
		features
			Alert: out event port;
			RespOut: out event data port AutomationResponse.i;
			Resp: in event data port AutomationResponse.i;
			Req: in event data port AutomationRequest.i;
		properties
			CASE_Properties::Monitoring => 100;
			CASE_Properties::Component_Spec => ("CASE_Monitor_Alert");
			CASE_Properties::Monitor_Latched => true;
        annex agree {**
                
            const is_latched : bool = Get_Property(this, CASE_Properties::Monitor_Latched);
--            const nMonitorInvocations : int = 2;
--
--            const FAIL : int = nMonitorInvocations + 1;
--            fun Inc (x:int) : int = if x < nMonitorInvocations then x + 1 else FAIL;
--
--            eq ticks : int =
--               (if (event (Resp) and not event (Req)) then FAIL else
--               if event (Req) then 1 else 0
--               )
--              ->
--               if not (event(Req) or event(Resp)) then
--                  (if (pre(ticks) = 0) then 0 else Inc (pre(ticks)))
--               else
--               if event(Resp) then
--                 (if (1 <= pre(ticks)) then 0 else FAIL)
--               else 
--                 1;

            eq FAIL : int = 2;          
            eq counter : int = (if event(Req) and not event(Resp) then 1 else 
                                if not event(Req) and event(Resp) then FAIL else
                                0) ->
                               (if event(Req) and not event(Resp) then 1 else 
                                if not event(Req) and event(Resp) then FAIL else
                                0); 
                               
            eq Policy : bool = counter < FAIL;
           
            -- auto-generated
            eq alerted : bool = (not Policy) -> ((is_latched and pre(alerted)) or not Policy);

            -- auto-generated
            guarantee "Alert port tracks alerted state variable" :
                event(Alert) <=>  alerted;
            
            -- auto-generated
            guarantee Req001_ReqRespMonitorData
                "Response event if not alerted" :
                if event(Alert) then 
                  not (event(RespOut))
                else if event(Resp) then
                        (event(RespOut) and (RespOut = Resp))
                     else
                        not (event(RespOut));
            
            guarantee Req002_ReqRespMonitorData
                "Response data is forwarded in not alerted" :
                event(RespOut) => RespOut = Resp;
         **};
	end CASE_Monitor;

	thread implementation CASE_Monitor.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 5ms;
	end CASE_Monitor.Impl;

	thread CASE_Filter
		features
			Input: in event data port AutomationResponse.i;
			Output: out event data port AutomationResponse.i;
		properties
			CASE_Properties::Filtering => 100;
			CASE_Properties::Component_Spec => ("CASE_Filter_Output");
		annex agree {**
            property CASE_Filter_policy = WELL_FORMED_AUTOMATION_RESPONSE(Input);
            guarantee CASE_Filter_Output "The filter output shall be well-formed" :
            if event(Input) and CASE_Filter_policy then
            event(Output) and Output = Input
            else
            not event(Output);
        **};
	end CASE_Filter;

	thread implementation CASE_Filter.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Filter.Impl;

	data AutomationRequest
	end AutomationRequest;

	data implementation AutomationRequest.i
		subcomponents
			TaskID: data Integer_64;
		properties
			HAMR::Bit_Codec_Max_Size => 128 bits;
	end AutomationRequest.i;

	data Waypoint
	end Waypoint;

	data implementation Waypoint.i
		subcomponents
			Latitude: data Float_64;
			Longitude: data Float_64;
			Altitude: data Float_32;
	end Waypoint.i;

	data WaypointArray
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Waypoint.i));
			Data_Model::Dimension => (1);
	end WaypointArray;

	data AutomationResponse
	end AutomationResponse;

	data implementation AutomationResponse.i
		subcomponents
			TaskID: data Integer_64;
			Waypoints: data WaypointArray;
		properties
			HAMR::Bit_Codec_Max_Size => 1664 bits;
	end AutomationResponse.i;

	----------
	-- AI --
	----------
	thread AI_thr
		features
			AutomationRequest: in event data port AutomationRequest.i;
			AirVehicleLocation: in event data port Waypoint.i;
			AutomationResponse: out event data port AutomationResponse.i;
		properties
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => 65536 Bytes;
			Source_text => ("third-party");
		annex agree {**
            assume "Automation requests are well-formed" :
                           event(AutomationRequest) => WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
            assume "Air vehicle location is well-formed" : 
                           event(AirVehicleLocation) => WELL_FORMED_WAYPOINT(AirVehicleLocation);
        **};
	end AI_thr;

	thread implementation AI_thr.i
	end AI_thr.i;

	----------------------
	-- Waypoint Manager --
	----------------------
	thread WaypointManager_thr
		features
			ReturnHome: in event port;
			AutomationResponse: in event data port AutomationResponse.i;
			AirVehicleLocation: in event data port Waypoint.i;
			NextWaypoint: out event data port Waypoint.i;
		properties
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => 65536 bytes;
			Source_text => ("src/wpm.c");
		annex agree {**
            assume "Return home and automation response are mutually exclusive" :
                                (event(ReturnHome) => not event(AutomationResponse))
                            and (event(AutomationResponse) => not event(ReturnHome));
            assume "Automation response is well-formed" :
                            event(AutomationResponse) => WELL_FORMED_AUTOMATION_RESPONSE(AutomationResponse);
            assume "Air vehicle state is well-formed" :
                            event(AirVehicleLocation) => WELL_FORMED_WAYPOINT(AirVehicleLocation);
            eq trigger : bool = event(AutomationResponse) or event(ReturnHome);
            guarantee "A next waypoint coincides with the automation response or return home" :
                            trigger => event(NextWaypoint);
            eq sawResponse : bool = trigger -> 
                                               if trigger then true else pre(sawResponse);
            guarantee "Next waypoint only after an automation response" :
                            event(NextWaypoint) => sawResponse;
            guarantee "Next waypoint is well-formed" : 
                            event(NextWaypoint) => WELL_FORMED_WAYPOINT(NextWaypoint);
            guarantee "Air vehicle location or automation response required for any next way point" :
                            event(NextWaypoint) => (trigger or event(AirVehicleLocation));
        **};
	end WaypointManager_thr;

	thread implementation WaypointManager_thr.i
	end WaypointManager_thr.i;

	------------------------
	--   Alert Manager    --
	------------------------
	thread AlertManager_thr
		features
			Alert: out event port;
		properties
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => 65536 bytes;
			Source_text => ("src/AlertManager.c");
		annex agree {**
            guarantee "The alert manager never alerts" :
                            event(Alert) = false;
        **};
	end AlertManager_thr;

	thread implementation AlertManager_thr.i
	end AlertManager_thr.i;

	---------------------
	-- Software system --
	---------------------
	process SW
		features
			AutomationRequest: in event data port AutomationRequest.i;
			AirVehicleLocation: in event data port Waypoint.i;
			NextWaypoint: out event data port Waypoint.i;
		annex agree {**
            assume "Automation request is well-formed" :
                            event(AutomationRequest) => 
                            WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
            assume "Air vehicle location is well-formed" :
                            event(AirVehicleLocation) => 
                            WELL_FORMED_WAYPOINT(AirVehicleLocation);
            guarantee "Next way point is well-formed" : 
                            event(NextWaypoint) => 
                            WELL_FORMED_WAYPOINT(NextWaypoint);
            eq sawRequest : bool = event(AutomationRequest) -> 
                                   if event(AutomationRequest) then true else pre(sawRequest);
            
            eq alert : bool;
            guarantee "First waypoint must be preceded by a request unless there is an internal alert" :
                            event(NextWaypoint) => (sawRequest or alert);
            
            eq FAIL : int = 2;                
            eq counter : int = (if event(AutomationRequest) then 0 else FAIL) ->
                               (if event(AutomationRequest) then 0 else
                                if pre(counter) < FAIL then pre(counter) + 1 
                                else FAIL
                               ); 
                                           
            eq first : bool = true -> 
                              if event(AutomationRequest) then true else
                              if pre(event(NextWaypoint)) then false else pre(first);
            guarantee "Automation response within a bounded time after the request" :
                            (event(NextWaypoint) and first) => (alert or counter < FAIL);
--            guarantee "Air vehicle location required with any waypoint after first" :
--                            event(NextWaypoint) => (first or event(AirVehicleLocation));
        **};
	end SW;

	process implementation SW.i
		subcomponents
			AI: thread AI_thr.i;
			WM: thread WaypointManager_thr.i;
			AM: thread AlertManager_thr.i;
		connections

			--------------------
			-- Primary Inputs --
			--------------------
			c01: port AutomationRequest -> AI.AutomationRequest;
			c03: port AirVehicleLocation -> AI.AirVehicleLocation;
			c04: port AirVehicleLocation -> WM.AirVehicleLocation;

			----------
			--  AI  --
			----------
			c05: port AI.AutomationResponse -> WM.AutomationResponse;

			---------
			-- WM --
			---------
			c06: port WM.NextWaypoint -> NextWaypoint;

			------------
			-- NOALERT -
			------------
			c07: port AM.Alert -> WM.ReturnHome;

		annex resolute {**
            check HAMR_Guidelines
        **};

		annex agree {**
            assert "Automation response is well-formed" :
                           event(AI.AutomationResponse) => WELL_FORMED_AUTOMATION_RESPONSE(AI.AutomationResponse);
            assert "Automation response only after request" :
                           event(AI.AutomationResponse) => sawRequest;
            assign alert = event(AM.Alert);
        **};
	end SW.i;

	process implementation SW.transform_i
		subcomponents
			AI: thread AI_thr.i;
			WM: thread WaypointManager_thr.i;
			Filter: thread CASE_Filter.Impl;
			Monitor: thread CASE_Monitor.Impl;
		connections

			--------------------
			-- Primary Inputs --
			--------------------
			c01: port AutomationRequest -> AI.AutomationRequest;
			c03: port AirVehicleLocation -> AI.AirVehicleLocation;
			c04: port AirVehicleLocation -> WM.AirVehicleLocation;

			----------
			--  AI  --
			----------
			c05: port AI.AutomationResponse -> Filter.Input;

			---------
			-- WM --
			---------
			c06: port WM.NextWaypoint -> NextWaypoint;

			c2: port Filter.Output -> Monitor.Resp;
			c3: port AutomationRequest -> Monitor.Req;
			c4: port Monitor.RespOut -> WM.AutomationResponse;
			c5: port Monitor.Alert -> WM.ReturnHome;

		annex resolute {**
            check HAMR_Guidelines
        **};

		annex agree {**
		    assign alert = event(WM.ReturnHome);    
		**};
	end SW.transform_i;

	annex agree {**
        const TASK_ID : int = 42;
        fun WELL_FORMED_WAYPOINT(point : Waypoint.i) : bool =
                            (point.Latitude >= -90.0 and point.Latitude <= 90.0)
                        and (point.Longitude >= -180.0 and point.Longitude <= 180.0) 
                        and (point.Altitude >= 10000.0 and point.Altitude <= 15000.0);
        fun WELL_FORMED_TASK_ID(id : int) : bool =
                    (id = TASK_ID);
        fun WELL_FORMED_AUTOMATION_REQUEST(msg : AutomationRequest.i) : bool =
                            WELL_FORMED_TASK_ID(msg.TaskID);
        fun WELL_FORMED_AUTOMATION_RESPONSE(msg : AutomationResponse.i) : bool =
                            (WELL_FORMED_TASK_ID(msg.TaskID))
                        and (forall waypoint in msg.Waypoints, WELL_FORMED_WAYPOINT(waypoint));
    **};
end SWTransform;