package SWTransform
public

	with Base_Types;
	renames Base_Types::all;

	with Data_Model;
	with HAMR;
	with CASE_Properties;

	thread CASE_Monitor
		features
			Alert: out event port;
			Output: out event data port AutomationResponse.i;
			Response: in event data port AutomationResponse.i;
			Request: in event data port AutomationRequest.i;
		properties
			CASE_Properties::Monitoring => 100;
			CASE_Properties::Component_Spec => ("CASE_Monitor_Alert");
			CASE_Properties::Monitor_Latched => true;
        annex agree {**
                
            const is_latched : bool = Get_Property(this, CASE_Properties::Monitor_Latched);
            
            eq req : bool = event(Request);
            eq rsp : bool = event(Response);
            eq nothing : bool = (not req) and (not rsp);
            eq today : bool = req and rsp;    
            eq yesterday : bool = false -> (pre (req) and (not pre (rsp)));
            eq bounded : bool = 
                   nothing
                or (req and rsp and (not yesterday))                       
                or ((not req) and rsp and yesterday);
            eq Policy : bool = bounded;
            eq alerted : bool = (not Policy) -> ((is_latched and pre(alerted)) or not Policy);

            guarantee "Alert port tracks alerted state variable" :
                event(Alert) <=> alerted;
            guarantee "Output if not alerted" :
                if alerted then (not event(Output)) else
                if rsp then (event(Output) and (Output = Response))
                else (not event(Output));
        **};
	end CASE_Monitor;

	thread implementation CASE_Monitor.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 5ms;
	end CASE_Monitor.Impl;

	thread CASE_Filter
		features
			Input: in event data port AutomationResponse.i;
			Output: out event data port AutomationResponse.i;
		properties
			CASE_Properties::Filtering => 100;
			CASE_Properties::Component_Spec => ("CASE_Filter_Output");
		annex agree {**
            property CASE_Filter_policy = WELL_FORMED_AUTOMATION_RESPONSE(Input);
            guarantee CASE_Filter_Output "The filter output shall be well-formed" :
            if event(Input) and CASE_Filter_policy then
            event(Output) and Output = Input
            else
            not event(Output);
        **};
	end CASE_Filter;

	thread implementation CASE_Filter.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Filter.Impl;

	data AutomationRequest
	end AutomationRequest;

	data implementation AutomationRequest.i
		subcomponents
			TaskID: data Integer_64;
		properties
			HAMR::Bit_Codec_Max_Size => 128 bits;
	end AutomationRequest.i;

	data Waypoint
	end Waypoint;

	data implementation Waypoint.i
		subcomponents
			Latitude: data Float_64;
			Longitude: data Float_64;
			Altitude: data Float_32;
	end Waypoint.i;

	data WaypointArray
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Waypoint.i));
			Data_Model::Dimension => (1);
	end WaypointArray;

	data AutomationResponse
	end AutomationResponse;

	data implementation AutomationResponse.i
		subcomponents
			TaskID: data Integer_64;
			Waypoints: data WaypointArray;
		properties
			HAMR::Bit_Codec_Max_Size => 1664 bits;
	end AutomationResponse.i;

	----------
	-- AI --
	----------
	thread AI_thr
		features
			AutomationRequest: in event data port AutomationRequest.i;
			AirVehicleLocation: in event data port Waypoint.i;
			AutomationResponse: out event data port AutomationResponse.i;
		properties
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => 65536 Bytes;
			Source_text => ("third-party");
		annex agree {**
		    eq req : bool = event(AutomationRequest);
            eq avl : bool = event(AirVehicleLocation);
            
            assume "Automation requests are well-formed" :
                req => WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
            assume "Air vehicle location is well-formed" : 
                avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);
        **};
	end AI_thr;

	thread implementation AI_thr.i
	end AI_thr.i;

	----------------------
	-- Waypoint Manager --
	----------------------
	thread WaypointManager_thr
		features
			Alert: in event port;
			AutomationResponse: in event data port AutomationResponse.i;
			AirVehicleLocation: in event data port Waypoint.i;
			Start: out event port;
			NextWaypoint: out event data port Waypoint.i;
		properties
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => 65536 bytes;
			Source_text => ("src/wpm.c");
		annex agree {**
		        
		    eq rsp : bool = event(AutomationResponse);
		    eq nwp : bool = event(NextWaypoint);
		    eq strt: bool = event(Start);
		    eq avl : bool = event(AirVehicleLocation);
		    eq alrt: bool = event(Alert);
		    assume "Automation response is well-formed" :
                rsp => WELL_FORMED_AUTOMATION_RESPONSE(AutomationResponse);
            assume "Air vehicle state is well-formed" :
                avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);
            
            eq once : bool = (nwp and rsp) -> 
                             if (nwp and rsp) then true else pre(once);
            guarantee "A response results in a next waypoint" :
                (rsp or (once and avl)) <=> nwp;                        
--            guarantee "A next waypoint coincides with the response or an air vehicle location if a response has been seen" :
--                nwp => (rsp or (once and avl));           
            guarantee "Next waypoint is well-formed" : 
                nwp => WELL_FORMED_WAYPOINT(NextWaypoint);
                
            guarantee "Start marks each new automation response" :
                strt <=> rsp;
--            guarantee "No waypoints if alert" :
--                nwp => (not alrt);
        **};
	end WaypointManager_thr;

	thread implementation WaypointManager_thr.i
	end WaypointManager_thr.i;

	------------------------
	--   Alert Manager    --
	------------------------
	thread AlertManager_thr
		features
			Alert: out event port;
		properties
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => 65536 bytes;
			Source_text => ("src/AlertManager.c");
		annex agree {**
            guarantee "The alert manager never alerts" :
                            event(Alert) = false;
        **};
	end AlertManager_thr;

	thread implementation AlertManager_thr.i
	end AlertManager_thr.i;

	---------------------
	-- Software system --
	---------------------
	process SW
		features
			AutomationRequest: in event data port AutomationRequest.i;
			AirVehicleLocation: in event data port Waypoint.i;
			NextWaypoint: out event data port Waypoint.i;
			Start: out event port;
			ReturnHome: out event port;
		annex agree {**
		        
		    eq req : bool = event(AutomationRequest);
            eq nwp : bool = event(NextWaypoint);
            eq avl : bool = event(AirVehicleLocation);
            eq strt: bool = event(Start);
            eq rh : bool = event(ReturnHome);
                        
            assume "Automation request is well-formed" :
                req => WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
            assume "Air vehicle location is well-formed" :
                avl => WELL_FORMED_WAYPOINT(AirVehicleLocation);
            
            eq first : bool = true -> 
                              if req then true else
                              if pre(nwp) then false else pre(first);                  
            eq rsp : bool = strt;
            eq once : bool = req -> if req then true else pre(once);  
            eq nothing : bool = (not req) and (not rsp);
            eq today : bool = req and rsp;    
            eq yesterday : bool = false -> (pre (req) and (not pre (rsp)));
            eq bounded : bool = 
                   nothing
                or (req and rsp and (not yesterday))                       
                or ((not req) and rsp and yesterday);
            eq Policy : bool = bounded;

            eq since : bool = rh or (Policy and (true -> pre(since)));
                           
            guarantee "Next waypoints only as a result of a request" :
                nwp => once;
--            guarantee "First waypoint zero or one cycles from request" :
--                bounded;
            guarantee "Air vehicle location required with any waypoint after first" :
                (nwp and not (first)) => event(AirVehicleLocation);
            guarantee "Next way point is well-formed" :
                nwp => WELL_FORMED_WAYPOINT(NextWaypoint);
            guarantee "Bounded and return home are mutually exclusive" :
                since;           
        **};
	end SW;

	process implementation SW.i
		subcomponents
			AI: thread AI_thr.i;
			WM: thread WaypointManager_thr.i;
			AM: thread AlertManager_thr.i;
		connections

			--------------------
			-- Primary Inputs --
			--------------------
			c01: port AutomationRequest -> AI.AutomationRequest;
			c03: port AirVehicleLocation -> AI.AirVehicleLocation;
			c04: port AirVehicleLocation -> WM.AirVehicleLocation;

			----------
			--  AI  --
			----------
			c05: port AI.AutomationResponse -> WM.AutomationResponse;

			---------
			-- WM --
			---------
			c06: port WM.NextWaypoint -> NextWaypoint;
            c07: port WM.Start -> Start;
            
			------------
			-- NOALERT -
			------------
			c08: port AM.Alert -> ReturnHome;
			c09: port AM.Alert -> WM.Alert;

		annex resolute {**
            check HAMR_Guidelines
        **};

		annex agree {**
            assert "Automation response is well-formed" :
                           event(AI.AutomationResponse) => WELL_FORMED_AUTOMATION_RESPONSE(AI.AutomationResponse);
            assert "Automation response only after request" :
                           event(AI.AutomationResponse) => once;
        **};
	end SW.i;

	process implementation SW.transform_i
		subcomponents
			AI: thread AI_thr.i;
			WM: thread WaypointManager_thr.i;
			Filter: thread CASE_Filter.Impl;
			Monitor: thread CASE_Monitor.Impl;
		connections

			--------------------
			-- Primary Inputs --
			--------------------
			c01: port AutomationRequest -> AI.AutomationRequest;
			c03: port AirVehicleLocation -> AI.AirVehicleLocation;
			c04: port AirVehicleLocation -> WM.AirVehicleLocation;

			----------
			--  AI  --
			----------
			c05: port AI.AutomationResponse -> Filter.Input;

			---------
			-- WM --
			---------
			c06: port WM.NextWaypoint -> NextWaypoint;
			c07: port WM.Start -> Start;

			c2: port Filter.Output -> Monitor.Response;
			c3: port AutomationRequest -> Monitor.Request;
			c4: port Monitor.Output -> WM.AutomationResponse;
			c5: port Monitor.Alert -> ReturnHome;
			c6: port Monitor.Alert -> WM.Alert;

		annex resolute {**
            check HAMR_Guidelines
        **};
	end SW.transform_i;

	annex agree {**
        const TASK_ID : int = 42;
        fun WELL_FORMED_WAYPOINT(point : Waypoint.i) : bool =
                            (point.Latitude >= -90.0 and point.Latitude <= 90.0)
                        and (point.Longitude >= -180.0 and point.Longitude <= 180.0) 
                        and (point.Altitude >= 10000.0 and point.Altitude <= 15000.0);
        fun WELL_FORMED_TASK_ID(id : int) : bool =
                    (id = TASK_ID);
        fun WELL_FORMED_AUTOMATION_REQUEST(msg : AutomationRequest.i) : bool =
                            WELL_FORMED_TASK_ID(msg.TaskID);
        fun WELL_FORMED_AUTOMATION_RESPONSE(msg : AutomationResponse.i) : bool =
                            (WELL_FORMED_TASK_ID(msg.TaskID))
                        and (forall waypoint in msg.Waypoints, WELL_FORMED_WAYPOINT(waypoint));
    **};
end SWTransform;